<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<title>금요일은 날코딩 — Editorial</title>
<meta name="description" content="스타트업 팀 전체가 금요일 하루 동안 AI 코딩 도구를 끈다. No AI Friday. 누가 가장 먼저 무너지고, 누가 가장 빛나는가. 그리고 정말로 생산성이 떨어지는가.">
<link rel="canonical" href="https://necromman.github.io/editorial/content/ai-withdrawal-series/no-ai-friday.html">
<meta property="og:type" content="article">
<meta property="og:title" content="금요일은 날코딩">
<meta property="og:description" content="팀 전체가 AI 코딩 도구를 끈다. No AI Friday. 2주간의 A/B 테스트가 시작된다.">
<meta property="og:url" content="https://necromman.github.io/editorial/content/ai-withdrawal-series/no-ai-friday.html">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="Editorial">
<meta property="article:published_time" content="2026-02-10">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="금요일은 날코딩">
<meta name="twitter:description" content="팀 전체가 AI 코딩 도구를 끈다. No AI Friday. 2주간의 A/B 테스트가 시작된다.">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"Article","headline":"금요일은 날코딩","description":"스타트업 팀 전체가 금요일 하루 동안 AI 코딩 도구를 끈다. No AI Friday. 누가 가장 먼저 무너지고, 누가 가장 빛나는가. 그리고 정말로 생산성이 떨어지는가.","datePublished":"2026-02-10","dateModified":"2026-02-10","publisher":{"@type":"Organization","name":"Editorial"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://necromman.github.io/editorial/content/ai-withdrawal-series/no-ai-friday.html"}}
</script>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<link rel="stylesheet" href="../../assets/editorial-base.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable-dynamic-subset.min.css">
<script>(function(){var t=localStorage.getItem('editorial-theme');if(!t)t=window.matchMedia('(prefers-color-scheme:dark)').matches?'dark':'light';document.documentElement.setAttribute('data-theme',t)})()</script>
<style>
  .masthead { border-bottom: none; margin-bottom: 32px; padding-bottom: 32px; }
  .masthead .issue { margin-bottom: 24px; }
  .masthead h1 { font-size: 3.2rem; font-weight: 900; line-height: 1.1; letter-spacing: -2px; }
  .masthead h1 strong { font-weight: 900; color: var(--accent); }
  .masthead .deck { max-width: 500px; margin: 24px auto 0; font-size: 1rem; color: var(--muted); line-height: 1.8; }

  .novel { font-size: 1.05rem; line-height: 2.05; color: var(--prose); margin-bottom: 28px; text-indent: 1em; }
  .novel-first { text-indent: 0; }
  .scene-break { text-align: center; padding: 40px 0; color: var(--muted); font-size: 1.2rem; letter-spacing: 12px; }
  .dialogue { font-size: 1.05rem; line-height: 2.05; color: var(--fg); margin-bottom: 20px; padding-left: 1em; text-indent: -1em; }
  .internal { font-size: 1.02rem; line-height: 2.05; color: var(--muted); margin-bottom: 28px; text-indent: 1em; }

  .ai-voice {
    font-size: 1.02rem; line-height: 2.0; color: var(--prose);
    margin-bottom: 24px; padding: 16px 20px;
    border-left: 3px solid var(--accent); background: var(--card-bg);
  }
  .ai-voice .ai-tag { font-family: var(--mono); font-size: 0.6rem; letter-spacing: 3px; text-transform: uppercase; color: var(--accent); margin-bottom: 6px; }

  .terminal {
    font-family: var(--mono); font-size: 0.82rem; line-height: 1.7;
    background: #2a2a28; color: #e8e4dc; padding: 24px 28px; margin: 32px 0;
    overflow-x: auto; border: 1px solid var(--fg);
  }
  .terminal .t-prompt { color: #6db36d; }
  .terminal .t-comment { color: #8a8680; }
  .terminal .t-error { color: #c43e2a; }
  .terminal .t-warn { color: #d4a843; }
  .terminal .t-key { color: #7cafc2; }
  .terminal .t-str { color: #c9b97a; }

  .char-intro {
    display: grid; grid-template-columns: auto 1fr; gap: 0 20px;
    align-items: baseline; margin: 40px 0 32px; padding-bottom: 20px;
    border-bottom: 1px solid var(--rule);
  }
  .char-intro .c-name { font-size: 1.4rem; font-weight: 700; color: var(--fg); }
  .char-intro .c-info { font-family: var(--mono); font-size: 0.7rem; letter-spacing: 2px; color: var(--muted); }

  .part-label { font-family: var(--mono); font-size: 0.6rem; letter-spacing: 5px; text-transform: uppercase; color: var(--accent); margin-bottom: 8px; }
  .part-title { font-size: 1.6rem; font-weight: 700; color: var(--fg); margin-bottom: 40px; letter-spacing: -0.5px; }
  .section-divider { margin-top: 64px; margin-bottom: 48px; padding-top: 32px; border-top: 1px solid var(--rule); }

  .slack-msg {
    border: 1px solid var(--rule); padding: 20px 24px; margin: 32px 0; background: var(--card-bg);
  }
  .slack-msg .s-header { display: flex; align-items: baseline; gap: 8px; margin-bottom: 8px; }
  .slack-msg .s-name { font-size: 0.9rem; font-weight: 700; color: var(--fg); }
  .slack-msg .s-time { font-family: var(--mono); font-size: 0.65rem; color: var(--muted); }
  .slack-msg .s-body { font-size: 0.95rem; line-height: 1.8; color: var(--prose); }
  .slack-msg .s-channel { font-family: var(--mono); font-size: 0.6rem; letter-spacing: 2px; color: var(--accent); margin-bottom: 12px; }

  .source-code {
    font-family: var(--mono); font-size: 0.8rem; line-height: 1.65;
    background: var(--card-bg); color: var(--prose); padding: 24px 28px; margin: 32px 0;
    overflow-x: auto; border: 1px solid var(--rule);
  }
  .source-code .sc-comment { color: var(--muted); }
  .source-code .sc-key { color: #5a7a9a; }
  .source-code .sc-str { color: #8a6a4a; }
  .source-code .sc-fn { color: var(--fg); font-weight: 600; }
  .source-code .sc-accent { color: var(--accent); font-weight: 600; }

  /* POV LABEL */
  .pov-label {
    font-family: var(--mono); font-size: 0.6rem; letter-spacing: 4px;
    text-transform: uppercase; color: var(--accent); margin: 48px 0 12px;
    padding-top: 24px; border-top: 1px solid var(--rule);
  }
  .pov-label:first-of-type { border-top: none; padding-top: 0; margin-top: 32px; }

  /* DATA TABLE */
  .data-table {
    width: 100%; border-collapse: collapse; margin: 32px 0;
    font-size: 0.88rem; line-height: 1.7;
  }
  .data-table th {
    font-family: var(--mono); font-size: 0.65rem; letter-spacing: 3px;
    text-transform: uppercase; color: var(--muted); text-align: left;
    padding: 12px 16px; border-bottom: 2px solid var(--fg);
  }
  .data-table td {
    padding: 12px 16px; border-bottom: 1px solid var(--rule); color: var(--prose);
  }
  .data-table .num {
    font-family: var(--mono); font-weight: 700; color: var(--accent);
  }

  .pull-quote {
    padding: 44px 0; border-top: 1px solid var(--fg); border-bottom: 1px solid var(--fg);
    text-align: center; margin: 48px 0;
  }
  .pull-quote p { font-size: 1.5rem; font-weight: 600; line-height: 1.6; color: var(--fg); }
  .pull-quote p strong { color: var(--accent); }

  .doc-excerpt {
    border-left: 3px solid var(--rule); background: var(--card-bg);
    padding: 20px 24px; margin: 32px 0; font-size: 0.88rem; line-height: 1.8; color: var(--secondary);
  }
  .doc-excerpt .doc-title {
    font-family: var(--mono); font-size: 0.6rem; letter-spacing: 3px;
    text-transform: uppercase; color: var(--muted); margin-bottom: 8px;
  }

  @media (max-width: 700px) {
    .masthead h1 { font-size: 2.2rem; }
    .char-intro { grid-template-columns: 1fr; }
    .data-table { font-size: 0.82rem; }
    .data-table th, .data-table td { padding: 8px 10px; }
  }
</style>
<script src="../../assets/nav.js" defer></script>
<script src="../../assets/series-nav.js" defer></script>
<script src="../../assets/theme-toggle.js" defer></script>
</head>
<body>
<article>
<div class="page">

<header class="masthead">
  <p class="issue">forbidden code — fiction 03</p>
  <h1>금요일은 <strong>날코딩</strong></h1>
  <p class="deck">팀 전체가 AI 코딩 도구를 끈다. 하루 동안.<br>누가 먼저 무너지고, 누가 가장 빛나는가.</p>
</header>

<main>

<!-- ───────── PART I ───────── -->

<section>
<div class="section-divider" style="border-top:none;margin-top:0;padding-top:0">
  <p class="part-label">Part I</p>
  <p class="part-title">"실험 설계"</p>
</div>

<p class="novel novel-first">2026년 3월 첫째 주. 1편 사건으로부터 3주 후.</p>

<p class="novel">진우의 "No AI Day" 슬랙 메시지가 예상치 못한 곳에서 반응을 얻었다. 외부 CTO 어드바이저 정윤호. 매주 화요일 오후에 2시간 출근하는, 회사에서 유일하게 넥타이를 매는 사람.</p>

<div class="slack-msg">
  <div class="s-channel">#general</div>
  <div class="s-header">
    <span class="s-name">정윤호 (CTO)</span>
    <span class="s-time">14:30</span>
  </div>
  <div class="s-body">재미있는 실험이네. METR 연구 알아? 숙련 개발자 16명한테 246개 태스크를 줬는데, AI 쓴 그룹이 오히려 19% 느렸어. 본인들은 20% 빨라졌다고 느꼈는데. 우리 팀으로도 데이터를 뽑아보면 좋겠다.</div>
</div>

<div class="slack-msg">
  <div class="s-header">
    <span class="s-name">김대표</span>
    <span class="s-time">14:32</span>
  </div>
  <div class="s-body">생산성 떨어지면 어쩌려고</div>
</div>

<div class="slack-msg">
  <div class="s-header">
    <span class="s-name">정윤호 (CTO)</span>
    <span class="s-time">14:33</span>
  </div>
  <div class="s-body">떨어지는지 안 떨어지는지를 확인하자는 거야. 2주면 돼. A/B로 비교하면 되고.</div>
</div>

<p class="novel">실험이 정식으로 설계됐다. CTO가 규칙을 정했다.</p>

<div class="slack-msg">
  <div class="s-channel">#dev-experiments</div>
  <div class="s-header">
    <span class="s-name">정윤호 (CTO)</span>
    <span class="s-time">15:00</span>
  </div>
  <div class="s-body">
    No AI Friday 실험 규칙:<br><br>
    1. 금요일 09:00~18:00 모든 AI 도구 비활성화<br>
    &nbsp;&nbsp;&nbsp;(Claude, Copilot, ChatGPT, Cursor, AI 코드 리뷰)<br>
    2. IDE 자동완성(IntelliSense)은 허용. AI 제안은 금지<br>
    3. 각자 PR 최소 1개 올릴 것<br>
    4. 2주간 진행: 금AI(AI O), 금날(AI X) 교대<br>
    5. 측정 지표: 코드 양, 버그 수, 리뷰 시간, 팀 대화량<br><br>
    첫 번째 No AI Friday: 이번 주 금요일
  </div>
</div>

<div class="slack-msg">
  <div class="s-header">
    <span class="s-name">김대표</span>
    <span class="s-time">15:05</span>
  </div>
  <div class="s-body">금요일에 클라이언트 미팅 안 잡혀 있는 거 맞지?</div>
</div>

<div class="slack-msg">
  <div class="s-header">
    <span class="s-name">박진우</span>
    <span class="s-time">15:06</span>
  </div>
  <div class="s-body">네 깨끗합니다</div>
</div>

<div class="slack-msg">
  <div class="s-header">
    <span class="s-name">이서연</span>
    <span class="s-time">15:07</span>
  </div>
  <div class="s-body">저는 평소랑 별 차이 없을 것 같은데</div>
</div>

<div class="slack-msg">
  <div class="s-header">
    <span class="s-name">윤한결</span>
    <span class="s-time">15:08</span>
  </div>
  <div class="s-body">... 열심히 하겠습니다</div>
</div>

<p class="novel">금요일 아침. 8시 55분. 진우가 먼저 사무실에 도착했다. 모니터를 켰다. 터미널을 열었다. 습관적으로 <code>claude</code>를 치려다 멈췄다. 오늘은 No AI Friday다.</p>

<p class="novel">서연이 출근했다. 한결이 출근했다. 9시 정각. CTO의 실험이 시작됐다.</p>

</section>

<!-- ───────── PART II ───────── -->

<div class="scene-break">* * *</div>

<section>
<div class="section-divider">
  <p class="part-label">Part II</p>
  <p class="part-title">금단 증상 보고서</p>
</div>

<p class="novel novel-first">오전 9시 ~ 오후 1시. 4시간의 기록.</p>

<!-- 진우 POV -->
<p class="pov-label">09:00 — 박진우</p>

<p class="novel novel-first">진우는 비교적 괜찮았다. 3주 전의 29시간 서바이벌이 예방접종이 된 것이다. 오늘 태스크는 대시보드 API에 캐시 레이어를 추가하는 것. Redis를 쓸지 인메모리를 쓸지는 이미 정했다. Redis. 이유도 안다 — 서버가 재시작해도 캐시가 유지되어야 하니까.</p>

<p class="novel">문제는 에러 핸들링 패턴이었다. 평소에는 Claude에게 "Redis 커넥션 실패 시 폴백 패턴 짜줘"라고 하면 try-catch 구조가 나왔다. 오늘은 직접 짜야 한다.</p>

<div class="source-code">
<span class="sc-comment"># 진우의 캐시 레이어 — 첫 번째 시도</span><br>
<span class="sc-key">async def</span> <span class="sc-fn">get_dashboard_data</span>(<span class="sc-key">self</span>, user_id: <span class="sc-key">str</span>):<br>
&nbsp;&nbsp;<span class="sc-key">try</span>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;cached = <span class="sc-key">await</span> <span class="sc-key">self</span>.redis.get(f<span class="sc-str">"dash:{user_id}"</span>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="sc-key">if</span> cached:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="sc-key">return</span> json.loads(cached)<br>
&nbsp;&nbsp;<span class="sc-key">except</span> RedisConnectionError:<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="sc-accent">logger.warning</span>(<span class="sc-str">"Redis unavailable, skipping cache"</span>)<br>
<br>
&nbsp;&nbsp;<span class="sc-comment"># Redis 실패 시 DB 직접 조회</span><br>
&nbsp;&nbsp;data = <span class="sc-key">await</span> <span class="sc-key">self</span>.repo.get_dashboard(user_id)<br>
<br>
&nbsp;&nbsp;<span class="sc-key">try</span>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="sc-key">await</span> <span class="sc-key">self</span>.redis.setex(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f<span class="sc-str">"dash:{user_id}"</span>, <span class="sc-str">300</span>, json.dumps(data)<br>
&nbsp;&nbsp;&nbsp;&nbsp;)<br>
&nbsp;&nbsp;<span class="sc-key">except</span> RedisConnectionError:<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="sc-key">pass</span> &nbsp;<span class="sc-comment"># 캐시 저장 실패는 무시</span><br>
<br>
&nbsp;&nbsp;<span class="sc-key">return</span> data
</div>

<p class="novel">간단한 코드다. 하지만 이 코드를 쓰는 데 30분이 걸렸다. <code>RedisConnectionError</code>가 정확히 어떤 클래스인지 redis-py 문서를 찾아보고, <code>setex</code>의 인자 순서를 확인하고, TTL 300초가 대시보드에 적절한지 생각했다. Claude였으면 3분이었을 것이다. 하지만 진우는 TTL을 왜 300으로 했는지 설명할 수 있다. 대시보드 데이터가 5분 이상 지연되면 사용자가 불만을 느끼기 시작하는 지점이니까.</p>

<p class="internal">3주 전에는 awk 명령어 하나 치는 데 20분 걸렸는데. 지금은 30분에 캐시 레이어를 짠다. 근육이 돌아오고 있다.</p>

<!-- 한결 POV -->
<p class="pov-label">09:00 — 윤한결</p>

<p class="novel novel-first">한결은 가장 심각한 금단 증상을 보였다.</p>

<p class="novel">오늘 태스크는 모바일 반응형 레이아웃 수정. 프로필 카드가 768px 이하에서 깨지는 문제. CSS를 직접 써야 한다.</p>

<div class="source-code">
<span class="sc-comment">/* 한결의 CSS — 10시 기준 */</span><br>
<span class="sc-key">.profile-card</span> {<br>
&nbsp;&nbsp;display: flex;<br>
&nbsp;&nbsp;<span class="sc-accent">justify-content</span>: center; <span class="sc-comment">/* 이게 맞나? 가로 정렬? */</span><br>
&nbsp;&nbsp;<span class="sc-accent">align-items</span>: center; &nbsp;&nbsp;&nbsp;<span class="sc-comment">/* 세로 정렬? 가로 정렬? */</span><br>
}
</div>

<p class="novel"><code>justify-content</code>와 <code>align-items</code>. 한결은 이 둘의 차이를 매번 헷갈린다. <code>flex-direction</code>이 <code>row</code>면 <code>justify-content</code>가 가로고 <code>align-items</code>가 세로다. <code>column</code>이면 반대다. 왜 반대인가? 주축(main axis)과 교차축(cross axis)이라는 개념 때문이다. 한결은 이것을 이번에 처음 이해했다.</p>

<p class="novel">한 시간 동안 작성한 CSS: 3줄. MDN에서 Flexbox 가이드를 처음부터 읽고 있었다.</p>

<p class="internal">AI한테 "이 카드 가운데 정렬해줘"라고 하면 5초면 됐는데. 5초짜리 일을 1시간째 하고 있다.</p>

<p class="novel">11시. 한결은 <code>flexbox</code>를 포기하고 <code>grid</code>로 바꿨다. 그런데 <code>grid</code>는 더 모른다.</p>

<div class="source-code">
<span class="sc-comment">/* 한결의 CSS — 11시 기준. flexbox → grid 전환 */</span><br>
<span class="sc-key">.profile-card</span> {<br>
&nbsp;&nbsp;display: grid;<br>
&nbsp;&nbsp;grid-template-columns: 80px 1fr;<br>
&nbsp;&nbsp;gap: 16px;<br>
&nbsp;&nbsp;align-items: start;<br>
}<br>
<br>
<span class="sc-key">@media</span> (max-width: 768px) {<br>
&nbsp;&nbsp;<span class="sc-key">.profile-card</span> {<br>
&nbsp;&nbsp;&nbsp;&nbsp;grid-template-columns: 1fr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;text-align: center;<br>
&nbsp;&nbsp;}<br>
}
</div>

<p class="novel">이 코드를 쓰는 데 40분이 걸렸다. MDN의 CSS Grid 가이드를 읽으면서, <code>grid-template-columns</code>가 컬럼 너비를 정의한다는 것을 알았다. <code>1fr</code>이 "남은 공간을 차지한다"는 뜻이라는 것을 알았다. 미디어 쿼리에서 <code>1fr</code>로 바꾸면 1열 레이아웃이 된다는 것을 알았다.</p>

<p class="novel">12시. 한결이 드디어 깨달은 것.</p>

<p class="internal">아... 그래서 2차원은 grid고 1차원은 flex인 거구나. grid는 행과 열을 동시에 제어하고, flex는 한 방향만 제어한다. 대학에서 과제 낼 때 이 차이를 몰랐다. AI가 알아서 골라줬으니까.</p>

<!-- 서연 POV -->
<p class="pov-label">09:00 — 이서연</p>

<p class="novel novel-first">서연은 유일하게 평소와 비슷한 속도였다. 서연에게 AI는 선택적 도구였다. 코드를 짤 때는 직접 쓰고, 반복적인 작업에만 AI를 활용했다.</p>

<p class="novel">하지만 서연에게도 비밀이 있었다.</p>

<p class="novel">오늘 태스크는 결제 완료 페이지의 리팩토링. 서연이 코드를 짜고, 테스트를 쓰려고 테스트 파일을 열었다. 빈 파일이 아니었다. 지난주 AI가 짜준 테스트가 이미 있었다.</p>

<p class="internal">테스트는 AI한테 시키고 있었다. 코드는 직접 짜지만, 테스트는 지루하니까. "이 컴포넌트의 엣지 케이스 테스트 짜줘." AI가 테스트를 생성하면 나는 돌리기만 했다. 테스트가 통과하면 넘어갔다.</p>

<p class="novel">오늘은 테스트도 직접 써야 한다. 서연은 Jest 파일을 열고 타이핑을 시작했다.</p>

<div class="source-code">
<span class="sc-comment">// 서연이 직접 작성하기 시작한 테스트</span><br>
<span class="sc-key">describe</span>(<span class="sc-str">'PaymentComplete'</span>, () =&gt; {<br>
&nbsp;&nbsp;<span class="sc-key">it</span>(<span class="sc-str">'결제 금액이 0원이면 에러 메시지를 표시한다'</span>, () =&gt; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="sc-comment">// 잠깐... 결제 금액이 0원인 경우가 있나?</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="sc-comment">// 쿠폰 100% 할인이면 0원 결제가 가능하다.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="sc-comment">// 그때 완료 페이지에 "0원"이 표시되면?</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="sc-comment">// UI에 "결제 완료: 0원" — 이건 맞는 건가?</span><br>
&nbsp;&nbsp;});<br>
});
</div>

<p class="novel">서연은 테스트를 쓰다가 자기 코드의 엣지 케이스를 발견했다. 결제 금액 0원. 쿠폰 100% 할인 시 발생하는 케이스. UI에서 "결제 완료: 0원"이 표시된다. 이것이 의도된 동작인가? 기획서에는 이 케이스가 없다. AI가 테스트를 짤 때는 이런 질문을 하지 않았다. AI는 코드의 동작을 테스트했지, 코드의 의도를 질문하지 않았다.</p>

<p class="dialogue">"진우야. 쿠폰 100% 할인이면 결제 금액 0원이 가능한 거 맞지?"</p>

<p class="dialogue">"어. 가능해. 왜?"</p>

<p class="dialogue">"결제 완료 페이지에서 0원이 그대로 표시되는데, 이거 의도된 거야?"</p>

<p class="novel">진우가 멈칫했다. "그건 기획에서 빠진 케이스인데."</p>

<p class="dialogue">"AI한테 테스트 시키면 이런 거 안 물어봐. 코드가 동작하는지만 확인하지, 기획이 맞는지는 안 물어보거든."</p>

<!-- 김대표 POV -->
<p class="pov-label">10:30 — 김대표</p>

<div class="slack-msg">
  <div class="s-header">
    <span class="s-name">김대표</span>
    <span class="s-time">10:34</span>
  </div>
  <div class="s-body">대시보드 API 캐시 작업 언제 되냐</div>
</div>

<div class="slack-msg">
  <div class="s-header">
    <span class="s-name">박진우</span>
    <span class="s-time">10:40</span>
  </div>
  <div class="s-body">오후에 PR 올리겠습니다</div>
</div>

<div class="slack-msg">
  <div class="s-header">
    <span class="s-name">김대표</span>
    <span class="s-time">11:45</span>
  </div>
  <div class="s-body">아직이냐</div>
</div>

<div class="slack-msg">
  <div class="s-header">
    <span class="s-name">김대표</span>
    <span class="s-time">12:50</span>
  </div>
  <div class="s-body">금요일이라 느린 거 아니지?</div>
</div>

<div class="slack-msg">
  <div class="s-header">
    <span class="s-name">박진우</span>
    <span class="s-time">12:52</span>
  </div>
  <div class="s-body">실험이라서 그런 건 아닙니다. 캐시 TTL 정책을 좀 더 꼼꼼하게 검토하고 있습니다.</div>
</div>

<p class="novel">진우는 "실험이라서 느린 건 아닙니다"라고 답했지만, 실험이라서 느린 것이 맞았다. 정확히는, 평소에는 AI가 대신 고민해주던 것을 오늘은 자기가 직접 고민하고 있으므로 느린 것이었다.</p>

</section>

<!-- ───────── PART III ───────── -->

<div class="scene-break">* * *</div>

<section>
<div class="section-divider">
  <p class="part-label">Part III</p>
  <p class="part-title">오후의 반전</p>
</div>

<p class="novel novel-first">오후 2시. 예상 밖의 일이 벌어지기 시작했다.</p>

<p class="novel">진우가 올린 캐시 레이어 PR을 서연이 리뷰했다. 버그를 발견했다. <code>RedisConnectionError</code> 이외의 예외 — 예를 들어 직렬화 실패 — 가 처리되지 않았다. 하지만 에러 메시지가 명확했다.</p>

<p class="dialogue">"진우야. <code>json.dumps</code>에서 <code>datetime</code> 객체가 직렬화 안 되는 케이스 있어."</p>

<p class="dialogue">"어디?"</p>

<p class="dialogue">"<code>get_dashboard</code> 반환값에 <code>last_login</code> 필드가 <code>datetime</code>이야. <code>json.dumps</code>가 터지는데, 에러 메시지가 정확해서 바로 찾았어."</p>

<p class="novel">진우가 고쳤다. <code>json.dumps</code>에 <code>default=str</code>을 추가하는 한 줄. 5분 만에 끝났다.</p>

<p class="internal">AI가 짰으면 이 에러가 안 났을 수도 있다. 하지만 AI가 짰으면 에러 메시지가 generic했을 것이다. "Internal Server Error." 그러면 원인을 찾는 데 5분이 아니라 30분이 걸렸을 것이다.</p>

<p class="novel">진우의 코드는 AI의 코드보다 버그가 하나 더 있었다. 하지만 버그의 원인이 명확했고, 수정이 빨랐다. AI의 코드는 버그가 적지만, 버그가 있을 때 원인을 찾기 어렵다. 에러 핸들링이 과도하게 추상화되어 있어서 어디서 터졌는지 추적하기 어려운 것이다.</p>

<p class="novel">오후 3시. 한결에게도 반전이 있었다.</p>

<p class="novel">4시간 동안 CSS와 씨름한 한결이 드디어 모바일 레이아웃을 완성했다. <code>grid</code>로 2열 레이아웃을 만들고, 미디어 쿼리로 1열로 전환하고, 아바타 이미지의 <code>object-fit</code>을 적용했다. 그리고 브라우저 개발자 도구에서 반응형 모드를 열어 직접 확인했다.</p>

<p class="dialogue">"서연 선배. 이거 한번 봐주세요."</p>

<p class="novel">서연이 한결의 모니터를 보았다. 프로필 카드가 768px에서 깔끔하게 1열로 전환되고 있었다.</p>

<p class="dialogue">"한결 씨, 이거 직접 짠 거 맞지?"</p>

<p class="dialogue">"네. 4시간 걸렸어요."</p>

<p class="dialogue">"잘했네. 근데 하나 물어볼게. <code>grid-template-columns: 80px 1fr</code>에서 왜 80px?"</p>

<p class="dialogue">"아바타 크기가 64px이고, 패딩 8px 양쪽이면 80px이니까요."</p>

<p class="novel">서연이 웃었다. "대답할 수 있네. 지난번이랑 다르다."</p>

<p class="novel">오후 4시. 팀이 모여서 코드 리뷰를 했다. 평소와 다른 점이 하나 있었다. <strong>대화가 많았다.</strong></p>

<p class="novel">AI가 있을 때는 각자 조용히 코딩했다. 모르는 게 있으면 AI에게 물었다. 동료에게 물어보는 것보다 AI에게 물어보는 것이 빨랐고, 부담이 없었다. 하지만 오늘은 AI가 없다. 모르는 게 있으면 동료에게 물어야 한다.</p>

<p class="dialogue">"서연 선배, Jest에서 async 컴포넌트 테스트할 때 <code>waitFor</code> 쓰는 게 맞아요?"</p>

<p class="dialogue">"맞아. <code>findBy</code>도 되는데, <code>waitFor</code>가 더 명시적이야."</p>

<p class="dialogue">"진우 선배, Redis <code>setex</code>랑 <code>set</code>에 <code>ex</code> 옵션 주는 거랑 뭐가 달라요?"</p>

<p class="dialogue">"같은 건데 <code>setex</code>는 Redis 2.0 호환이라 레거시야. <code>set</code>에 <code>ex</code> 쓰는 게 낫다. 내 코드 고쳐야겠네."</p>

<p class="novel">진우가 한결의 질문 덕에 자기 코드의 개선점을 찾았다. 이런 일은 AI와의 대화에서는 일어나지 않는다. AI는 질문에 답하지, 역으로 질문하지 않는다.</p>

<div class="pull-quote">
  <p>AI에게 물으면 답이 온다<br><strong>동료에게 물으면 질문이 돌아온다</strong></p>
</div>

<p class="novel">오후 5시. 서연이 테스트를 직접 쓰면서 발견한 것들을 정리했다.</p>

<p class="dialogue">"테스트를 직접 쓰니까 이상한 게 보여. AI한테 시키면 AI가 코드의 동작을 테스트하거든. '이 함수를 호출하면 이 값이 나온다.' 근데 직접 쓰면 동작이 아니라 <strong>의도</strong>를 테스트하게 돼. '이 결과가 사용자한테 맞는 건가?'"</p>

<p class="novel">서연이 오늘 발견한 엣지 케이스 목록: 결제 금액 0원 표시, 결제 실패 시 뒤로가기 무한 루프, 영수증 PDF에 회사 이름 누락. 세 가지 모두 AI가 짜준 테스트에서는 잡히지 않았던 것들이다. AI는 코드가 동작하는지 확인했지, 코드가 올바른지는 묻지 않았다.</p>

</section>

<!-- ───────── PART IV ───────── -->

<div class="scene-break">* * *</div>

<section>
<div class="section-divider">
  <p class="part-label">Part IV</p>
  <p class="part-title">월요일의 데이터</p>
</div>

<p class="novel novel-first">2주 후. 월요일 오전. 회의실.</p>

<p class="novel">CTO 정윤호가 2주간의 A/B 데이터를 화면에 띄웠다. 금요일 2회(AI 사용) vs 금요일 2회(AI 미사용).</p>

<table class="data-table">
  <thead>
    <tr>
      <th>metric</th>
      <th>ai friday</th>
      <th>no ai friday</th>
      <th>diff</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>코드 양 (줄)</td>
      <td>평균 340줄/인</td>
      <td>평균 220줄/인</td>
      <td class="num">-35%</td>
    </tr>
    <tr>
      <td>PR 버그 (리뷰 후 발견)</td>
      <td>평균 3.2건/PR</td>
      <td>평균 1.8건/PR</td>
      <td class="num">-44%</td>
    </tr>
    <tr>
      <td>코드 리뷰 시간</td>
      <td>평균 42분/PR</td>
      <td>평균 22분/PR</td>
      <td class="num">-48%</td>
    </tr>
    <tr>
      <td>팀 대화 (슬랙 메시지)</td>
      <td>평균 18건</td>
      <td>평균 54건</td>
      <td class="num">+200%</td>
    </tr>
    <tr>
      <td>기획 불일치 발견</td>
      <td>0건</td>
      <td>3건</td>
      <td class="num">+3</td>
    </tr>
  </tbody>
</table>

<p class="novel">회의실이 조용했다. 김대표가 먼저 입을 열었다.</p>

<p class="dialogue">"코드 양이 35% 줄었잖아."</p>

<p class="dialogue">"맞습니다." CTO가 답했다. "하지만 버그가 44% 줄었고, 리뷰 시간이 48% 줄었습니다. 코드가 적은 게 아니라 불필요한 코드가 없는 겁니다."</p>

<p class="novel">진우가 보충했다.</p>

<p class="dialogue">"AI가 짜면 방어적 코드가 많아요. try-catch가 중첩되고, 타입 체크가 과도하고, 에러 핸들링이 추상화돼 있어요. 코드 양은 많은데 에러가 터지면 추적이 어렵죠. 직접 짜면 코드가 적지만 에러 메시지가 구체적이에요."</p>

<div class="doc-excerpt">
  <div class="doc-title">coderabbit — state of ai vs human code</div>
  AI가 생성한 PR은 사람이 작성한 PR에 비해 버그가 <strong>1.7배</strong> 많았다. 가독성 문제는 <strong>3배</strong>, 성능 비효율은 <strong>8배</strong> 증가했다. AI 코드는 "작동하지만 최적이 아닌" 상태로 출하되는 경향이 있다.
</div>

<p class="novel">CTO가 또 하나의 데이터를 가리켰다.</p>

<p class="dialogue">"팀 대화량이 3배입니다. AI가 없으니까 서로 묻는 겁니다. 그리고 이 대화에서 기획 불일치 3건을 찾았습니다. AI에게 물으면 코드 답이 오지만, 동료에게 물으면 기획 답이 옵니다."</p>

<p class="novel">서연이 덧붙였다.</p>

<p class="dialogue">"테스트도요. AI가 짜면 코드의 동작을 테스트하는데, 직접 쓰면 코드의 의도를 테스트하게 돼요. 이번에 결제 금액 0원 케이스를 찾은 게 그 예시예요."</p>

<p class="novel">김대표가 팔짱을 끼고 물었다.</p>

<p class="dialogue">"투자자한테 '우리는 일주일에 하루 AI를 안 씁니다'라고 하면 뭐라고 생각하겠어."</p>

<p class="novel">CTO가 대답했다.</p>

<p class="dialogue">"'우리 팀은 AI를 쓸 때와 안 쓸 때의 차이를 데이터로 측정했고, 그 결과를 바탕으로 AI 사용 전략을 최적화했습니다.' 투자자가 싫어할 말은 아닙니다."</p>

<p class="novel">METR 연구. 숙련 개발자 16명, 246개 태스크. AI를 쓴 그룹이 19% 느렸다. 하지만 본인들은 20% 빨라졌다고 느꼈다. 인식과 현실의 괴리 40%포인트. 이 팀의 데이터도 비슷했다. 코드 양은 줄었지만, 품질은 올라갔다.</p>

<p class="novel">CTO가 제안했다.</p>

<p class="dialogue">"격주 금요일을 'No AI Friday'로 정식 운영하자. 강제가 아니라 선택. 하지만 참여자는 데이터를 기록해줘."</p>

<p class="novel">김대표가 한숨을 쉬며 고개를 끄덕였다.</p>

<p class="dialogue">"좋아. 대신 고객 이슈 있으면 AI 써."</p>

<p class="dialogue">"당연하죠."</p>

<p class="novel">회의가 끝나고 자리로 돌아가는 길. 한결이 진우에게 말했다.</p>

<p class="dialogue">"진우 선배. 다음 금요일도 No AI죠?"</p>

<p class="dialogue">"당연하지."</p>

<p class="dialogue">"이번엔 CSS 4시간 안 걸릴 거예요."</p>

<p class="novel">진우가 웃었다.</p>

<p class="novel">다음 금요일. 한결이 아침에 사무실에 들어오며 말했다.</p>

<p class="dialogue">"오늘은 No AI Friday잖아요."</p>

<p class="novel">진우와 서연이 동시에 고개를 돌렸다. 한결이 먼저 말한 것은 처음이었다. 2주 전에 "... 열심히 하겠습니다"라고 작게 말했던 신입이, 오늘은 먼저 No AI Friday를 선언했다.</p>

<p class="novel">서연이 커피를 건네며 말했다.</p>

<p class="dialogue">"한결 씨, 오늘 태스크 뭐야?"</p>

<p class="dialogue">"결제 완료 페이지 리디자인이요. 서연 선배가 찾은 0원 케이스 처리도 포함해서."</p>

<p class="dialogue">"기획팀이랑 얘기했어?"</p>

<p class="dialogue">"네. 어제 슬랙으로 확인했어요. 0원 결제는 '무료 결제 완료'로 표시하기로 했습니다."</p>

<p class="novel">서연이 한결을 보았다. 2주 전 코드 리뷰에서 <code>useCallback</code>을 왜 넣었는지 대답하지 못했던 신입이, 이제 기획팀에 먼저 확인하고 온다. 코드를 짜기 전에 의도를 확인한다.</p>

<p class="novel">이것이 AI가 할 수 없는 일이다. AI는 코드를 짠다. 하지만 "이 결과가 사용자한테 맞는 건가?"라는 질문은 하지 않는다. 그 질문은 사람만 할 수 있다.</p>

</section>

</main>

<div class="closing">
  <h2>코드 양은 35% 줄었다<br><strong>버그는 44% 줄었다</strong></h2>
  <p class="sub">AI에게 물으면 답이 온다. 동료에게 물으면 질문이 돌아온다. 그 질문이 기획의 빈틈을 찾는다.</p>
</div>

<footer class="footer">
  <p>This is a work of fiction &middot; Characters and events are imaginary</p>
  <p>METR AI Tool Productivity Study (2025) &middot; CodeRabbit State of AI vs Human Code Report &middot; Stack Overflow 2025 Survey &middot; Research assisted by Claude &middot; 2026</p>
</footer>

</div>
</article>
</body>
</html>
