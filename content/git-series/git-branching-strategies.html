<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<title>브랜치 전략은 팀의 거울이다 — Editorial</title>
<meta name="description" content="Git Flow, GitHub Flow, Trunk-Based Development. 세 가지 브랜치 전략의 철학과 문화를 비교하고, PR 작성법, merge/rebase/squash 전쟁, Git Hooks까지 팀 협업의 모든 것.">
<link rel="canonical" href="https://necromman.github.io/editorial/content/git-series/git-branching-strategies.html">
<meta property="og:type" content="article">
<meta property="og:title" content="브랜치 전략은 팀의 거울이다">
<meta property="og:description" content="Git Flow, GitHub Flow, Trunk-Based Development. 세 가지 브랜치 전략의 철학과 문화를 비교하고, PR 작성법, merge/rebase/squash 전쟁, Git Hooks까지 팀 협업의 모든 것.">
<meta property="og:url" content="https://necromman.github.io/editorial/content/git-series/git-branching-strategies.html">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="Editorial">
<meta property="article:published_time" content="2026-02-09">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="브랜치 전략은 팀의 거울이다">
<meta name="twitter:description" content="Git Flow, GitHub Flow, Trunk-Based Development. 세 가지 브랜치 전략의 철학과 문화를 비교하고, PR 작성법, merge/rebase/squash 전쟁, Git Hooks까지 팀 협업의 모든 것.">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"Article","headline":"브랜치 전략은 팀의 거울이다","description":"Git Flow, GitHub Flow, Trunk-Based Development. 세 가지 브랜치 전략의 철학과 문화를 비교하고, PR 작성법, merge/rebase/squash 전쟁, Git Hooks까지 팀 협업의 모든 것.","datePublished":"2026-02-09","dateModified":"2026-02-09","publisher":{"@type":"Organization","name":"Editorial"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://necromman.github.io/editorial/content/git-series/git-branching-strategies.html"}}
</script>
<link rel="preload" href="../../assets/fonts/source-serif-4-latin-wght-normal.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable-dynamic-subset.min.css">
<link rel="stylesheet" href="../../assets/editorial-base.css">
<script>(function(){var t=localStorage.getItem('editorial-theme');if(!t)t=window.matchMedia('(prefers-color-scheme:dark)').matches?'dark':'light';document.documentElement.setAttribute('data-theme',t)})()</script>
<style>
  .masthead .deck { max-width: 560px; }

  /* CODE BLOCK */
  .code-block {
    background: var(--card-bg);
    border: 1px solid var(--rule);
    padding: 20px 24px;
    font-family: var(--mono);
    font-size: 0.76rem;
    line-height: 1.75;
    overflow-x: auto;
    white-space: pre;
    margin: 24px 0;
    color: var(--prose);
    border-radius: 0;
  }
  .code-block .code-label {
    font-size: 0.6rem;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: var(--accent);
    display: block;
    margin-bottom: 12px;
    font-weight: 700;
  }
  .code-block .code-comment {
    color: var(--muted);
  }
  .code-block .code-key {
    font-weight: 700;
    color: var(--fg);
  }

  /* STRATEGY DETAIL */
  .strategy-detail {
    margin: 32px 0;
    padding: 24px 28px;
    background: var(--card-bg);
    border-left: 3px solid var(--accent);
  }
  .strategy-detail .sd-label {
    font-family: var(--mono);
    font-size: 0.6rem;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: var(--accent);
    display: block;
    margin-bottom: 8px;
    font-weight: 700;
  }
  .strategy-detail h4 {
    font-size: 1rem;
    font-weight: 700;
    margin-bottom: 10px;
    line-height: 1.4;
  }
  .strategy-detail p {
    font-size: 0.88rem;
    color: var(--secondary);
    line-height: 1.75;
  }
  .strategy-detail .sd-tags {
    margin-top: 10px;
    font-family: var(--mono);
    font-size: 0.68rem;
    color: var(--muted);
    letter-spacing: 1px;
  }

  /* GUIDE TABLE */
  .guide-table {
    width: 100%;
    border-collapse: collapse;
    margin: 32px 0;
    font-size: 0.85rem;
  }
  .guide-table th {
    background: var(--card-bg);
    font-weight: 700;
    text-align: left;
    padding: 12px 16px;
    border: 1px solid var(--rule);
    font-size: 0.78rem;
    color: var(--fg);
  }
  .guide-table td {
    padding: 10px 16px;
    border: 1px solid var(--rule);
    color: var(--prose);
    line-height: 1.6;
    vertical-align: top;
  }
  .guide-table td strong {
    color: var(--accent);
    font-weight: 700;
  }

  /* PR STRUCTURE */
  .pr-template {
    background: var(--card-bg);
    border: 1px solid var(--rule);
    padding: 24px 28px;
    margin: 24px 0;
  }
  .pr-template .pr-section {
    margin-bottom: 16px;
    padding-bottom: 16px;
    border-bottom: 1px solid var(--rule);
  }
  .pr-template .pr-section:last-child {
    margin-bottom: 0;
    padding-bottom: 0;
    border-bottom: none;
  }
  .pr-template .pr-heading {
    font-family: var(--mono);
    font-size: 0.72rem;
    font-weight: 700;
    color: var(--accent);
    margin-bottom: 6px;
  }
  .pr-template .pr-body {
    font-size: 0.85rem;
    color: var(--secondary);
    line-height: 1.7;
  }

  /* FLOWCHART */
  .flowchart {
    display: grid;
    gap: 1px;
    background: var(--rule);
    border: 1px solid var(--rule);
    margin: 32px 0;
  }
  .flow-step {
    background: var(--bg);
    padding: 16px 20px;
    display: grid;
    grid-template-columns: 40px 1fr;
    gap: 12px;
    align-items: center;
  }
  .flow-step .f-num {
    font-family: var(--mono);
    font-size: 1.1rem;
    font-weight: 700;
    color: var(--accent);
    text-align: center;
  }
  .flow-step .f-text {
    font-size: 0.88rem;
    color: var(--prose);
    line-height: 1.6;
  }
  .flow-arrow-row {
    background: var(--bg);
    text-align: center;
    padding: 4px 0;
    font-size: 0.85rem;
    color: var(--muted);
  }

  /* 2-column mechanism-row variant */
  .mechanism-2col { grid-template-columns: 1fr 1fr; }

  /* HOOK BLOCK */
  .hook-block {
    margin: 32px 0;
    border: 1px solid var(--rule);
  }
  .hook-block .hb-header {
    background: var(--card-bg);
    padding: 16px 24px;
    border-bottom: 1px solid var(--rule);
  }
  .hook-block .hb-label {
    font-family: var(--mono);
    font-size: 0.6rem;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: var(--accent);
    font-weight: 700;
    display: block;
    margin-bottom: 4px;
  }
  .hook-block .hb-title {
    font-size: 1rem;
    font-weight: 700;
    color: var(--fg);
  }
  .hook-block .hb-desc {
    font-size: 0.82rem;
    color: var(--muted);
    margin-top: 4px;
    line-height: 1.6;
  }
  .hook-block .hb-code {
    padding: 16px 24px;
    font-family: var(--mono);
    font-size: 0.72rem;
    line-height: 1.8;
    white-space: pre;
    overflow-x: auto;
    color: var(--prose);
  }
  .hook-block .hb-code .code-comment {
    color: var(--muted);
  }
  .hook-block .hb-code .code-key {
    font-weight: 700;
    color: var(--fg);
  }

  @media (max-width: 700px) {
    .mechanism-2col { grid-template-columns: 1fr; }
    .guide-table { font-size: 0.78rem; }
    .guide-table th, .guide-table td { padding: 8px 10px; }
    .flow-step { grid-template-columns: 32px 1fr; }
  }
</style>
<script src="../../assets/nav.js" defer></script>
<script src="../../assets/series-nav.js" defer></script>
<script src="../../assets/theme-toggle.js" defer></script>
</head>
<body>
<div class="page">

  <article>
  <header class="masthead">
    <div class="issue">Git Survival Guide — Article 04</div>
    <h1>브랜치 전략은 팀의<br><strong>거울</strong>이다</h1>
    <p class="deck">Git Flow, GitHub Flow, Trunk-Based Development. 세 가지 철학, 세 가지 문화. 당신의 팀은 어떤 거울을 보고 있는가.</p>
  </header>

  <main>

  <!-- PART I: 세 가지 철학 -->
  <section>
    <div class="section-head">
      <span class="num">Part I</span>
      <h2>세 가지 <strong>철학</strong></h2>
    </div>

    <p class="prose">
      브랜치 전략은 단순한 기술 선택이 아니다. 팀이 코드를 어떻게 만들고, 어떻게 검증하고, 어떻게 배포하는지를 규정하는 <strong>문화적 결정</strong>이다. 2010년 Vincent Driessen이 "A successful Git branching model"을 발표한 이후, Git 세계는 세 가지 거대한 철학으로 나뉘었다. 어느 것이 옳고 그른 것이 아니다. 팀의 규모, 배포 주기, 제품의 성격에 따라 답이 달라진다.
    </p>

    <div class="mechanism-row">
      <div class="mechanism">
        <div class="m-label">Strategy 01</div>
        <h3>Git Flow</h3>
        <p><strong>main + develop + feature + release + hotfix.</strong> 다섯 종류의 브랜치가 엄격한 계층 구조를 형성한다. 릴리즈 주기가 길고, 배포 전 QA가 필수인 환경에 적합하다.</p>
      </div>
      <div class="mechanism">
        <div class="m-label">Strategy 02</div>
        <h3>GitHub Flow</h3>
        <p><strong>main + feature branch + PR.</strong> 브랜치는 두 종류뿐이다. feature에서 작업하고, PR로 리뷰받고, main에 머지하면 즉시 배포. 단순함이 핵심이다.</p>
      </div>
      <div class="mechanism">
        <div class="m-label">Strategy 03</div>
        <h3>Trunk-Based</h3>
        <p><strong>main에 직접 커밋하거나, 1~2일짜리 짧은 브랜치.</strong> Feature Flag로 미완성 코드를 숨기고, CI/CD 파이프라인이 모든 것을 자동으로 검증한다.</p>
      </div>
    </div>

    <div class="strategy-detail">
      <span class="sd-label">Git Flow</span>
      <h4>Vincent Driessen, 2010 — 엄격한 계층의 미학</h4>
      <p>
        main은 프로덕션과 1:1로 동기화된다. develop은 다음 릴리즈의 통합 브랜치다. 개발자는 feature 브랜치에서 작업하고, develop에 머지한다. 릴리즈가 다가오면 release 브랜치를 만들어 최종 QA를 진행하고, main에 머지하면서 태그를 단다. 프로덕션에 긴급 버그가 발생하면 hotfix 브랜치로 패치한다. 모바일 앱, 패키지 소프트웨어, 삼성 SDS, LG CNS 등 대기업 SI 프로젝트에서 여전히 주류다. 릴리즈 주기가 2주 이상이고, QA 팀이 별도로 존재하는 조직에 적합하다.
      </p>
      <div class="sd-tags">단점: 브랜치 복잡도 높음, CI/CD 파이프라인 설정 복잡, CD에 부적합</div>
    </div>

    <div class="strategy-detail">
      <span class="sd-label">GitHub Flow</span>
      <h4>Scott Chacon, 2011 — 단순함의 승리</h4>
      <p>
        main 브랜치 하나와 feature 브랜치만 존재한다. 개발자는 main에서 feature 브랜치를 만들고, 작업이 끝나면 Pull Request를 연다. 코드 리뷰를 거쳐 main에 머지되면 <strong>즉시 프로덕션에 배포</strong>된다. 웹 서비스, SaaS 제품에 가장 적합하다. 한국에서는 토스, 당근마켓, 배달의민족 등 테크 기업이 이 전략을 채택하고 있다.
      </p>
      <div class="sd-tags">적합: 웹 서비스, SaaS, 빠른 배포 주기, 소규모~중규모 팀</div>
    </div>

    <div class="strategy-detail">
      <span class="sd-label">Trunk-Based Development</span>
      <h4>Google, Meta — 극단적 단순함</h4>
      <p>
        모든 개발자가 main(trunk)에 직접 커밋하거나, 최대 1~2일 내에 머지되는 극히 짧은 브랜치를 사용한다. 미완성 코드는 <strong>Feature Flag</strong>로 숨긴다. Google의 모노레포(10억 줄 이상의 코드)가 이 전략으로 운영된다. CI/CD 파이프라인의 자동화 수준이 매우 높아야 하며, 테스트 커버리지가 낮으면 재앙이 된다. 한국에서는 카카오뱅크, 토스 일부 팀이 도입을 진행 중이다.
      </p>
      <div class="sd-tags">필수: Feature Flags, 높은 테스트 커버리지, 강력한 CI/CD</div>
    </div>

    <div class="pull-quote">
      <p>브랜치 전략을 바꾸는 것은<br>코드를 바꾸는 것이 아니라 <strong>문화를 바꾸는 것</strong>이다.</p>
    </div>
  </section>

  <!-- PART II: 브랜치 전략 선택 가이드 -->
  <section>
    <div class="section-head">
      <span class="num">Part II</span>
      <h2>브랜치 전략 <strong>선택</strong> 가이드</h2>
    </div>

    <p class="prose">
      "우리 팀에 맞는 전략이 뭔가?"라는 질문에 정답은 없다. 하지만 <strong>팀 규모, 배포 빈도, 제품 특성</strong> 세 가지 축으로 선택지를 좁힐 수 있다. 중요한 것은 전략을 선택한 후 팀 전체가 동일한 규칙을 따르는 것이다. 전략의 혼재가 전략의 부재보다 위험하다.
    </p>

    <div style="font-family:var(--serif);font-size:0.8rem;letter-spacing:2px;color:var(--muted);font-weight:700;margin-bottom:16px;margin-top:40px">팀 규모별 권장 전략</div>

    <table class="guide-table">
      <thead>
        <tr>
          <th>팀 규모</th>
          <th>권장 전략</th>
          <th>이유</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>1~3명</strong></td>
          <td>GitHub Flow</td>
          <td>리뷰어가 부족하므로 프로세스가 단순해야 한다. Trunk-Based도 가능하지만, PR 기반 리뷰 습관을 초기에 잡는 것이 장기적으로 유리하다.</td>
        </tr>
        <tr>
          <td><strong>4~10명</strong></td>
          <td>GitHub Flow 또는 Trunk-Based</td>
          <td>배포 주기에 따라 갈린다. 일 1회 이상 배포하면 Trunk-Based, 주 1~2회면 GitHub Flow가 적합하다.</td>
        </tr>
        <tr>
          <td><strong>10명 이상</strong></td>
          <td>Trunk-Based (Feature Flag 필수)</td>
          <td>장기 브랜치는 머지 지옥을 초래한다. Feature Flag로 기능 단위 격리가 필수다. Google, Meta의 선택에는 이유가 있다.</td>
        </tr>
        <tr>
          <td><strong>엔터프라이즈</strong></td>
          <td>Git Flow 또는 변형</td>
          <td>QA 프로세스, 감사 추적, 릴리즈 승인이 필요한 규제 산업(금융, 의료)에서는 Git Flow의 엄격함이 오히려 장점이다.</td>
        </tr>
      </tbody>
    </table>

    <div style="font-family:var(--serif);font-size:0.8rem;letter-spacing:2px;color:var(--muted);font-weight:700;margin-bottom:16px;margin-top:48px">배포 빈도별 권장 전략</div>

    <table class="guide-table">
      <thead>
        <tr>
          <th>배포 빈도</th>
          <th>권장 전략</th>
          <th>핵심 요건</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>주 1회 이하</strong></td>
          <td>Git Flow</td>
          <td>release 브랜치에서 충분한 QA 기간 확보. 핫픽스 프로세스 정의 필수.</td>
        </tr>
        <tr>
          <td><strong>주 2~5회</strong></td>
          <td>GitHub Flow</td>
          <td>자동화 테스트 + CI 파이프라인. PR 머지 = 배포 트리거.</td>
        </tr>
        <tr>
          <td><strong>일 수십 회</strong></td>
          <td>Trunk-Based</td>
          <td>Feature Flag 인프라, 카나리 배포, 자동 롤백. 테스트 커버리지 80% 이상.</td>
        </tr>
      </tbody>
    </table>

    <div style="font-family:var(--serif);font-size:0.8rem;letter-spacing:2px;color:var(--muted);font-weight:700;margin-bottom:16px;margin-top:48px">의사결정 흐름</div>

    <div class="flowchart">
      <div class="flow-step">
        <span class="f-num">Q1</span>
        <span class="f-text">릴리즈 주기가 2주 이상이고, QA팀이 별도로 있는가?</span>
      </div>
      <div class="flow-arrow-row">YES -> Git Flow / NO -> 다음 질문</div>
      <div class="flow-step">
        <span class="f-num">Q2</span>
        <span class="f-text">하루에 여러 번 배포하며, Feature Flag 인프라가 있는가?</span>
      </div>
      <div class="flow-arrow-row">YES -> Trunk-Based / NO -> 다음 질문</div>
      <div class="flow-step">
        <span class="f-num">Q3</span>
        <span class="f-text">PR 기반 코드 리뷰 문화가 정착되어 있는가?</span>
      </div>
      <div class="flow-arrow-row">YES -> GitHub Flow / NO -> GitHub Flow (도입하면서 시작)</div>
    </div>

    <div style="font-family:var(--serif);font-size:0.8rem;letter-spacing:2px;color:var(--muted);font-weight:700;margin-bottom:16px;margin-top:48px">전략 비교 요약</div>

    <table class="guide-table">
      <thead>
        <tr>
          <th>항목</th>
          <th>Git Flow</th>
          <th>GitHub Flow</th>
          <th>Trunk-Based</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>브랜치 수</strong></td>
          <td>5종</td>
          <td>2종</td>
          <td>1종 (+ 초단기)</td>
        </tr>
        <tr>
          <td><strong>복잡도</strong></td>
          <td>높음</td>
          <td>낮음</td>
          <td>낮음 (인프라 복잡)</td>
        </tr>
        <tr>
          <td><strong>배포 주기</strong></td>
          <td>주~월</td>
          <td>일~주</td>
          <td>시간~일</td>
        </tr>
        <tr>
          <td><strong>머지 충돌</strong></td>
          <td>잦음</td>
          <td>보통</td>
          <td>적음</td>
        </tr>
        <tr>
          <td><strong>필수 인프라</strong></td>
          <td>QA 환경</td>
          <td>CI/CD</td>
          <td>Feature Flag + CI/CD</td>
        </tr>
        <tr>
          <td><strong>한국 사례</strong></td>
          <td>삼성 SDS, LG CNS</td>
          <td>토스, 당근, 배민</td>
          <td>카카오뱅크 (도입 중)</td>
        </tr>
      </tbody>
    </table>
  </section>

  <!-- PART III: PR을 잘 쓰는 사람이 팀을 바꾼다 -->
  <section>
    <div class="section-head">
      <span class="num">Part III</span>
      <h2>PR을 잘 쓰는 사람이 <strong>팀을 바꾼다</strong></h2>
    </div>

    <p class="prose">
      Pull Request는 코드를 머지하는 관문이 아니다. <strong>팀의 지식을 공유하는 채널</strong>이다. Google의 연구에 따르면, 리뷰어가 PR을 읽는 데 걸리는 시간은 코드 라인 수에 비례하지 않는다. <strong>200~400줄</strong>이 리뷰 효율의 최적 구간이다. 400줄을 넘으면 리뷰어의 집중도가 급격히 떨어지고, "LGTM"(Looks Good To Me)이라는 고무도장만 찍힌다. 1,000줄짜리 PR은 리뷰가 아니라 통과 의례다.
    </p>

    <div class="mechanism-row mechanism-2col">
      <div class="mechanism">
        <div class="m-label">Rule 01</div>
        <h3>작게 쪼개라</h3>
        <p><strong>한 PR에 하나의 관심사.</strong> 리팩토링과 기능 추가를 한 PR에 담지 않는다. "이것도 고쳤습니다"는 리뷰어에 대한 폭력이다. Google 내부 데이터: 200줄 이하 PR의 머지 속도가 800줄 이상 대비 3배 빠르다.</p>
      </div>
      <div class="mechanism">
        <div class="m-label">Rule 02</div>
        <h3>맥락을 제공하라</h3>
        <p><strong>"왜"를 먼저 쓴다.</strong> 리뷰어는 코드를 읽기 전에 PR 본문을 읽는다. Jira/Linear 티켓 번호, 변경 이유, 영향 범위가 없는 PR은 리뷰할 수 없다.</p>
      </div>
    </div>

    <div style="font-family:var(--serif);font-size:0.8rem;letter-spacing:2px;color:var(--muted);font-weight:700;margin-bottom:16px;margin-top:40px">PR 템플릿 — 한국 팀 실전용</div>

    <div class="pr-template">
      <div class="pr-section">
        <div class="pr-heading">## What (무엇을 변경했는가)</div>
        <div class="pr-body">주문 목록 API에 cursor 기반 페이지네이션을 추가했습니다.<br>관련 티켓: JIRA-1234 / Linear FE-567</div>
      </div>
      <div class="pr-section">
        <div class="pr-heading">## Why (왜 변경했는가)</div>
        <div class="pr-body">기존 offset 방식이 10만 건 이상에서 3초 이상 응답 지연을 발생시켰습니다.<br>QA팀 리포트: QA-2026-089</div>
      </div>
      <div class="pr-section">
        <div class="pr-heading">## How to test (어떻게 테스트하는가)</div>
        <div class="pr-body">1. pytest tests/api/test_orders.py -v 실행<br>2. /v1/orders?cursor=xxx&limit=20 호출 확인<br>3. 10만 건 데이터에서 응답 시간 500ms 이하 확인</div>
      </div>
      <div class="pr-section">
        <div class="pr-heading">## Screenshots / Logs</div>
        <div class="pr-body">변경 전: avg 3.2s / 변경 후: avg 0.3s (벤치마크 첨부)</div>
      </div>
    </div>

    <p class="prose">
      한국 팀에서는 Jira, Linear, Notion의 티켓 번호를 PR 제목에 포함하는 것이 관례다. 카카오는 사내 Git 가이드에서 PR 제목 형식을 <strong>[JIRA-번호] 변경 요약</strong>으로 규정하고 있고, 네이버 Works도 유사한 컨벤션을 따른다. 형식이 중요한 것이 아니라, 팀 전체가 <strong>동일한 형식</strong>을 따르는 것이 중요하다.
    </p>

    <div style="font-family:var(--serif);font-size:0.8rem;letter-spacing:2px;color:var(--muted);font-weight:700;margin-bottom:16px;margin-top:48px">Draft PR — 완성 전에 피드백받기</div>

    <p class="prose">
      Draft PR은 "아직 완성되지 않았지만 방향을 확인받고 싶다"는 신호다. 대규모 리팩토링이나 아키텍처 변경을 시작할 때, 3일 동안 혼자 작업한 뒤 "이건 좀..."이라는 리뷰를 받는 것보다, <strong>첫날 Draft PR을 열어서 설계 방향을 합의</strong>하는 것이 합리적이다. GitHub에서는 "Ready for review" 버튼을 누르기 전까지 머지가 차단된다.
    </p>

    <div class="code-block"><span class="code-label">Draft PR 생성</span>
<span class="code-comment"># Draft PR 생성 (GitHub CLI)</span>
<span class="code-key">gh pr create --draft --title "[JIRA-1234] 주문 API 페이지네이션 변경"</span>

<span class="code-comment"># Draft → Ready for review 전환</span>
<span class="code-key">gh pr ready</span></div>

    <div style="font-family:var(--serif);font-size:0.8rem;letter-spacing:2px;color:var(--muted);font-weight:700;margin-bottom:16px;margin-top:48px">Conventional Commits — 커밋 메시지 자동화</div>

    <p class="prose">
      커밋 메시지에 규칙이 없으면 git log는 곧 쓰레기통이 된다. <strong>Conventional Commits</strong>는 <code>feat:</code>, <code>fix:</code>, <code>chore:</code> 등의 접두사로 커밋의 성격을 명시하는 표준이다. 이 규칙을 도구로 강제하면 사람의 의지에 의존하지 않아도 된다.
    </p>

    <div class="code-block"><span class="code-label">Conventional Commits 설정</span>
<span class="code-comment"># commitizen — 대화형 커밋 메시지 생성</span>
<span class="code-key">npm install -D commitizen cz-conventional-changelog</span>
<span class="code-comment"># package.json에 추가</span>
"config": { "commitizen": { "path": "cz-conventional-changelog" } }

<span class="code-comment"># commitlint — 커밋 메시지 규칙 검증</span>
<span class="code-key">npm install -D @commitlint/cli @commitlint/config-conventional</span>
<span class="code-comment"># commitlint.config.js</span>
module.exports = { extends: ['@commitlint/config-conventional'] };

<span class="code-comment"># husky — Git Hooks로 자동 강제</span>
<span class="code-key">npx husky add .husky/commit-msg 'npx commitlint --edit $1'</span></div>

    <div class="code-block"><span class="code-label">Conventional Commits 예시</span>
<span class="code-key">feat:</span> 주문 목록 cursor 페이지네이션 추가
<span class="code-key">fix:</span> 결제 금액 소수점 반올림 오류 수정
<span class="code-key">refactor:</span> OrderService 의존성 주입 구조 변경
<span class="code-key">docs:</span> API 엔드포인트 문서 업데이트
<span class="code-key">test:</span> 주문 생성 통합 테스트 추가
<span class="code-key">chore:</span> ESLint 설정 업데이트
<span class="code-key">ci:</span> GitHub Actions 캐시 설정 추가

<span class="code-comment"># BREAKING CHANGE 포함 시</span>
<span class="code-key">feat!:</span> 주문 API 응답 형식 변경 (v1 → v2)</div>

    <div class="pull-quote">
      <p>좋은 PR은 코드를 설명하지 않는다.<br><strong>결정을 설명한다.</strong></p>
    </div>
  </section>

  <!-- PART IV: merge vs rebase vs squash -->
  <section>
    <div class="section-head">
      <span class="num">Part IV</span>
      <h2>merge vs rebase vs squash<br><strong>히스토리 전쟁</strong></h2>
    </div>

    <p class="prose">
      "merge할까, rebase할까?" — Git을 쓰는 모든 팀이 한 번은 겪는 논쟁이다. 정답은 없지만 원칙은 있다. 각 전략이 만들어내는 히스토리의 모양이 다르고, 그 모양이 팀의 작업 방식에 영향을 준다. <strong>히스토리의 가독성과 추적 가능성 사이의 트레이드오프</strong>를 이해해야 한다.
    </p>

    <div class="mechanism-row">
      <div class="mechanism">
        <div class="m-label">Merge</div>
        <h3>토폴로지 보존</h3>
        <p>두 브랜치의 히스토리를 <strong>그대로 보존</strong>하고 머지 커밋을 생성한다. 브랜치가 언제 분기되고 합류했는지 그래프로 확인할 수 있다. 히스토리가 복잡해지지만, 작업의 맥락이 보존된다.</p>
      </div>
      <div class="mechanism">
        <div class="m-label">Rebase</div>
        <h3>선형 히스토리</h3>
        <p>feature 브랜치의 커밋을 <strong>main 위에 재배치</strong>한다. 히스토리가 일직선이 되어 읽기 쉽다. 단, Golden Rule: <strong>이미 push한 커밋은 절대 rebase하지 않는다.</strong></p>
      </div>
      <div class="mechanism">
        <div class="m-label">Squash Merge</div>
        <h3>PR 단위 정리</h3>
        <p>feature 브랜치의 모든 커밋을 <strong>하나로 압축</strong>하여 main에 머지한다. main의 히스토리가 PR 단위로 깔끔해진다. 개별 커밋 히스토리는 사라진다.</p>
      </div>
    </div>

    <div class="code-block"><span class="code-label">merge — 토폴로지 보존</span>
<span class="code-comment"># feature 브랜치를 main에 머지 (머지 커밋 생성)</span>
<span class="code-key">git checkout main</span>
<span class="code-key">git merge feature/order-api</span>

<span class="code-comment"># 결과 히스토리</span>
*   <span class="code-key">Merge branch 'feature/order-api'</span>
|\
| * feat: 주문 목록 API 추가
| * feat: 주문 상세 API 추가
| * test: 주문 API 테스트 추가
|/
* 이전 커밋</div>

    <div class="code-block"><span class="code-label">rebase — 선형 히스토리</span>
<span class="code-comment"># feature 브랜치를 main 위로 재배치</span>
<span class="code-key">git checkout feature/order-api</span>
<span class="code-key">git rebase main</span>
<span class="code-key">git checkout main</span>
<span class="code-key">git merge feature/order-api</span>  <span class="code-comment"># fast-forward</span>

<span class="code-comment"># 결과 히스토리 (일직선)</span>
* feat: 주문 목록 API 추가
* feat: 주문 상세 API 추가
* test: 주문 API 테스트 추가
* 이전 커밋</div>

    <div class="code-block"><span class="code-label">squash merge — PR 단위 정리</span>
<span class="code-comment"># feature 브랜치의 모든 커밋을 하나로 압축하여 머지</span>
<span class="code-key">git checkout main</span>
<span class="code-key">git merge --squash feature/order-api</span>
<span class="code-key">git commit -m "feat: 주문 API 추가 (#123)"</span>

<span class="code-comment"># 결과 히스토리 (1커밋 = 1PR)</span>
* feat: 주문 API 추가 (#123)
* 이전 커밋</div>

    <div class="warning-box">
      <div class="w-title">Rebase의 Golden Rule</div>
      <ol class="warning-list">
        <li><strong>이미 push한 커밋은 절대 rebase하지 않는다.</strong> 다른 개발자가 같은 커밋을 기반으로 작업 중일 수 있다</li>
        <li>rebase는 커밋의 SHA를 변경한다. push된 커밋의 SHA가 바뀌면 협업자의 히스토리가 꼬인다</li>
        <li>로컬에서만 작업한 커밋은 자유롭게 rebase해도 된다</li>
        <li>force push가 필요한 상황이 오면 <strong>git push --force-with-lease</strong>를 사용한다. --force보다 안전하다</li>
        <li>팀에서 rebase를 쓰기로 했다면, 모든 멤버가 Golden Rule을 이해해야 한다</li>
      </ol>
    </div>

    <div style="font-family:var(--serif);font-size:0.8rem;letter-spacing:2px;color:var(--muted);font-weight:700;margin-bottom:16px;margin-top:48px">한국 팀의 현실 — git pull --rebase</div>

    <p class="prose">
      한국 IT 기업의 상당수가 <strong>git pull --rebase</strong>를 기본값으로 설정한다. 일반 git pull은 매번 불필요한 머지 커밋을 생성하여 히스토리를 지저분하게 만들기 때문이다. 글로벌 설정으로 한 번 지정하면 모든 프로젝트에 적용된다.
    </p>

    <div class="code-block"><span class="code-label">git pull --rebase 설정</span>
<span class="code-comment"># 글로벌 설정 — 모든 프로젝트에 적용</span>
<span class="code-key">git config --global pull.rebase true</span>

<span class="code-comment"># 프로젝트별 설정</span>
<span class="code-key">git config pull.rebase true</span>

<span class="code-comment"># autostash — rebase 전 자동 stash, 후 자동 pop</span>
<span class="code-key">git config --global rebase.autoStash true</span></div>

    <div style="font-family:var(--serif);font-size:0.8rem;letter-spacing:2px;color:var(--muted);font-weight:700;margin-bottom:16px;margin-top:48px">머지 충돌 해결 — 실전 가이드</div>

    <p class="prose">
      머지 충돌은 피할 수 없다. 두 사람이 같은 파일의 같은 줄을 수정하면 Git은 자동으로 합칠 수 없다. <strong>VS Code의 3-way 머지 에디터</strong>가 가장 직관적인 해결 도구다. Git 2.35+에서 지원하는 <code>diff3</code> 스타일은 충돌 영역에 <strong>원본(base)</strong>까지 보여주어 판단을 돕는다.
    </p>

    <div class="code-block"><span class="code-label">머지 충돌 해결</span>
<span class="code-comment"># diff3 스타일로 충돌 표시 (원본 포함)</span>
<span class="code-key">git config --global merge.conflictstyle diff3</span>

<span class="code-comment"># 충돌 발생 시 diff3 출력</span>
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD (현재 브랜치)
const pageSize = 20;
||||||| base (원본)
const pageSize = 10;
=======
const pageSize = 50;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/pagination (머지 대상)

<span class="code-comment"># VS Code에서 3-way 머지 에디터 열기</span>
<span class="code-key">git mergetool</span>  <span class="code-comment"># VS Code가 기본 머지 도구로 설정된 경우</span>

<span class="code-comment"># 충돌 해결 후</span>
<span class="code-key">git add .</span>
<span class="code-key">git commit</span>  <span class="code-comment"># 자동 생성된 머지 커밋 메시지 사용</span></div>

    <div class="pull-quote">
      <p>히스토리는 읽히기 위해 존재한다.<br><strong>읽히지 않는 히스토리는 쓰지 않은 것과 같다.</strong></p>
    </div>
  </section>

  <!-- PART V: Git Hooks -->
  <section>
    <div class="section-head">
      <span class="num">Part V</span>
      <h2>Git Hooks — 팀의 <strong>품질 게이트</strong></h2>
    </div>

    <p class="prose">
      코드 리뷰만으로는 품질을 보장할 수 없다. 리뷰어도 사람이고, 피로하면 놓친다. <strong>Git Hooks</strong>는 커밋, 푸시 등 Git 이벤트에 자동으로 실행되는 스크립트다. lint 규칙 위반, 타입 에러, 테스트 실패를 커밋 단계에서 차단한다. 사람의 의지가 아닌 <strong>시스템으로 품질을 강제</strong>하는 것이 핵심이다.
    </p>

    <div class="mechanism-row">
      <div class="mechanism">
        <div class="m-label">Hook 01</div>
        <h3>pre-commit</h3>
        <p><strong>커밋 직전</strong>에 실행. lint, 포맷팅, 타입 체크를 수행한다. <code>lint-staged</code>와 함께 사용하면 변경된 파일만 검사하여 속도를 유지한다.</p>
      </div>
      <div class="mechanism">
        <div class="m-label">Hook 02</div>
        <h3>commit-msg</h3>
        <p><strong>커밋 메시지 작성 후</strong>에 실행. Conventional Commits 형식 검증, 티켓 번호 포함 여부 확인 등을 자동으로 수행한다.</p>
      </div>
      <div class="mechanism">
        <div class="m-label">Hook 03</div>
        <h3>pre-push</h3>
        <p><strong>push 직전</strong>에 실행. 전체 테스트 스위트를 돌려서 깨진 코드가 원격 저장소에 올라가는 것을 방지한다.</p>
      </div>
    </div>

    <div style="font-family:var(--serif);font-size:0.8rem;letter-spacing:2px;color:var(--muted);font-weight:700;margin-bottom:16px;margin-top:48px">husky + lint-staged — Node.js 프로젝트</div>

    <p class="prose">
      <strong>husky</strong>는 Git Hooks를 프로젝트에 쉽게 설정하는 도구다. <strong>lint-staged</strong>는 staged 파일(git add된 파일)만 대상으로 lint를 실행한다. 이 조합이 Node.js 생태계의 표준이다.
    </p>

    <div class="hook-block">
      <div class="hb-header">
        <span class="hb-label">pre-commit</span>
        <span class="hb-title">lint-staged + ESLint + Prettier</span>
        <span class="hb-desc">변경된 파일만 대상으로 lint와 포맷팅을 검사한다</span>
      </div>
      <div class="hb-code"><span class="code-comment"># husky + lint-staged 설치</span>
<span class="code-key">npm install -D husky lint-staged</span>
<span class="code-key">npx husky init</span>

<span class="code-comment"># .husky/pre-commit</span>
npx lint-staged

<span class="code-comment"># package.json — lint-staged 설정</span>
"lint-staged": {
  "*.{js,ts,tsx}": [
    "eslint --fix",
    "prettier --write"
  ],
  "*.css": [
    "prettier --write"
  ]
}</div>
    </div>

    <div class="hook-block">
      <div class="hb-header">
        <span class="hb-label">commit-msg</span>
        <span class="hb-title">Conventional Commits 검증</span>
        <span class="hb-desc">커밋 메시지가 feat:/fix:/chore: 형식을 따르는지 자동 확인</span>
      </div>
      <div class="hb-code"><span class="code-comment"># commitlint 설치</span>
<span class="code-key">npm install -D @commitlint/cli @commitlint/config-conventional</span>

<span class="code-comment"># commitlint.config.js</span>
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'subject-case': [2, 'never', ['start-case', 'pascal-case']],
    'header-max-length': [2, 'always', 100]
  }
};

<span class="code-comment"># .husky/commit-msg</span>
npx commitlint --edit $1</div>
    </div>

    <div class="hook-block">
      <div class="hb-header">
        <span class="hb-label">pre-push</span>
        <span class="hb-title">테스트 실행</span>
        <span class="hb-desc">push 전에 테스트를 돌려서 깨진 코드가 원격에 올라가지 않도록 한다</span>
      </div>
      <div class="hb-code"><span class="code-comment"># .husky/pre-push</span>
npm test

<span class="code-comment"># 또는 더 세밀하게</span>
<span class="code-key">#!/bin/sh</span>
echo "Running tests before push..."
npm run test:unit || {
  echo "Tests failed. Push aborted."
  exit 1
}
echo "All tests passed."</div>
    </div>

    <div style="font-family:var(--serif);font-size:0.8rem;letter-spacing:2px;color:var(--muted);font-weight:700;margin-bottom:16px;margin-top:48px">pre-commit (Python) — Python 프로젝트</div>

    <p class="prose">
      Python 생태계에서는 <strong>pre-commit</strong> 프레임워크가 표준이다. <code>.pre-commit-config.yaml</code> 파일 하나로 여러 언어의 hook을 관리한다. ruff, black, mypy, isort 등 Python 도구뿐 아니라, prettier, eslint 같은 다른 언어 도구도 함께 설정할 수 있다.
    </p>

    <div class="hook-block">
      <div class="hb-header">
        <span class="hb-label">Python</span>
        <span class="hb-title">pre-commit 프레임워크</span>
        <span class="hb-desc">.pre-commit-config.yaml 하나로 모든 hook을 관리한다</span>
      </div>
      <div class="hb-code"><span class="code-comment"># 설치</span>
<span class="code-key">pip install pre-commit</span>
<span class="code-key">pre-commit install</span>

<span class="code-comment"># .pre-commit-config.yaml</span>
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.9.4
    hooks:
      - id: ruff        <span class="code-comment"># lint</span>
        args: [--fix]
      - id: ruff-format <span class="code-comment"># format</span>

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.14.1
    hooks:
      - id: mypy        <span class="code-comment"># type check</span>

  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v5.0.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-json
      - id: detect-private-key  <span class="code-comment"># 보안: 비밀키 감지</span></div>
    </div>

    <div class="warning-box">
      <div class="w-title">Git Hooks 도입 시 주의사항</div>
      <ol class="warning-list">
        <li><strong>--no-verify를 습관적으로 쓰는 팀원이 있으면 의미가 없다.</strong> CI에서 동일한 검사를 이중으로 실행해야 한다</li>
        <li>pre-commit hook이 5초를 넘으면 개발자가 비활성화한다. lint-staged로 변경 파일만 검사하여 속도를 유지한다</li>
        <li>pre-push에서 전체 테스트를 돌리면 push가 수분 걸릴 수 있다. 빠른 단위 테스트만 돌리고, 통합 테스트는 CI에 위임한다</li>
        <li>husky v9+는 .husky/ 디렉토리에 쉘 스크립트를 직접 작성한다. package.json의 scripts로 위임하지 않는다</li>
        <li>팀 전체가 동일한 hook을 사용하려면 <strong>설정 파일을 git에 커밋</strong>해야 한다. .husky/는 기본적으로 커밋 대상이다</li>
      </ol>
    </div>

    <div class="code-block"><span class="code-label">Git Hooks 실전 조합 — 추천 설정</span>
<span class="code-comment"># 권장 파이프라인</span>
<span class="code-key">pre-commit</span>     → lint-staged (ESLint + Prettier) <span class="code-comment">← 빠름 (변경 파일만)</span>
<span class="code-key">commit-msg</span>     → commitlint (Conventional Commits) <span class="code-comment">← 즉시</span>
<span class="code-key">pre-push</span>       → unit test <span class="code-comment">← 보통 (단위 테스트만)</span>
<span class="code-key">CI (remote)</span>    → full test + build + security scan <span class="code-comment">← 느림 (전체)</span>

<span class="code-comment"># 핵심 원칙</span>
<span class="code-comment"># 로컬 hook = 빠르게, 자주 실행되는 검사</span>
<span class="code-comment"># CI = 느리지만 포괄적인 검사</span>
<span class="code-comment"># 둘 다 통과해야 머지 가능</span></div>
  </section>

  </main>

  <div class="closing">
    <h2>좋은 도구는 팀의 습관이 된다<br><strong>좋은 전략은 팀의 문화가 된다</strong></h2>
    <p class="sub">브랜치 전략, PR, 커밋 규칙, Git Hooks. 결국 도구가 아니라 합의의 문제다. 팀이 같은 방향을 보고 있다면, 어떤 전략이든 작동한다.</p>
  </div>

  <footer class="footer">
    <p>
      Vincent Driessen, "A successful Git branching model" (nvie.com, 2010)<br>
      Scott Chacon, "GitHub Flow" (scottchacon.com, 2011)<br>
      Google Engineering Practices, "Code Review Developer Guide" (google.github.io)<br>
      Conventional Commits Specification (conventionalcommits.org)<br>
      Trunk Based Development (trunkbaseddevelopment.com)<br>
      Atlassian, "Comparing Workflows" (atlassian.com/git/tutorials)<br>
      husky Documentation (typicode.github.io/husky)<br>
      pre-commit Framework (pre-commit.com)
    </p>
  </footer>

  </article>

</div>
</body>
</html>
