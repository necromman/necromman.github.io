---
layout: layouts/article.njk
pageTitle: "force push 하나로 팀을 멸망시키는 법"
description: "Jenkins 150개 레포 롤백, GitLab DB 삭제 유튜브 라이브 복구, 삼성 190GB 유출. Git 사고는 영화보다 극적이다. reset --hard부터 filter-repo까지, 실전 복구 매뉴얼."
ogDescription: "Jenkins 150개 레포 롤백, GitLab DB 삭제 유튜브 라이브 복구, 삼성 190GB 유출. Git 사고는 영화보다 극적이다. 실전 복구 매뉴얼."
datePublished: "2026-02-09"
---
<style>
  .masthead .deck { max-width: 540px; }

  /* CODE BLOCK */
  .code-block {
    background: var(--card-bg);
    border: 1px solid var(--rule);
    padding: 20px 24px;
    font-family: var(--mono);
    font-size: 0.76rem;
    line-height: 1.75;
    overflow-x: auto;
    white-space: pre;
    margin: 24px 0;
    color: var(--prose);
    border-radius: 0;
  }
  .code-block .code-label {
    font-size: 0.6rem;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: var(--accent);
    display: block;
    margin-bottom: 12px;
    font-weight: 700;
  }
  .code-block .code-comment {
    color: var(--muted);
  }
  .code-block .code-key {
    font-weight: 700;
    color: var(--fg);
  }

  /* TIMELINE — 1px gap grid */
  .timeline {
    margin: 40px 0 48px;
    list-style: none;
    background: var(--rule);
    border: 1px solid var(--rule);
    display: grid;
    gap: 1px;
  }
  .timeline li {
    display: grid;
    grid-template-columns: 100px 1fr;
    background: var(--bg);
  }
  .timeline .t-time {
    font-family: var(--mono);
    font-size: 0.8rem;
    font-weight: 700;
    color: var(--accent);
    padding: 20px 12px;
    text-align: right;
    background: var(--card-bg);
  }
  .timeline .t-desc {
    font-size: 0.92rem;
    color: var(--prose);
    line-height: 1.7;
    padding: 20px 24px;
  }
  .timeline .t-desc strong {
    font-weight: 700;
    color: var(--fg);
  }

  /* 2-COLUMN MECHANISM */
  .mechanism-2col {
    grid-template-columns: 1fr 1fr;
  }

  /* STAT HIGHLIGHT */
  .stat-highlight {
    text-align: center;
    padding: 32px 24px;
    margin: 40px 0;
    background: var(--card-bg);
    border: 1px solid var(--rule);
  }
  .stat-highlight .stat-num {
    font-family: var(--mono);
    font-size: 2.8rem;
    font-weight: 800;
    color: var(--accent);
    line-height: 1;
    margin-bottom: 8px;
  }
  .stat-highlight .stat-label {
    font-size: 0.85rem;
    color: var(--muted);
    line-height: 1.5;
  }

  /* INCIDENT CARD */
  .incident-card {
    border: 1px solid var(--rule);
    padding: 28px 32px;
    margin: 32px 0;
  }
  .incident-card .inc-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    flex-wrap: wrap;
    gap: 12px;
    margin-bottom: 14px;
  }
  .incident-card .inc-name {
    font-family: var(--mono);
    font-size: 0.7rem;
    font-weight: 700;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--accent);
  }
  .incident-card .inc-year {
    font-family: var(--mono);
    font-size: 0.65rem;
    font-weight: 600;
    letter-spacing: 2px;
    color: var(--muted);
  }
  .incident-card h3 {
    font-size: 1.15rem;
    font-weight: 700;
    margin-bottom: 12px;
  }
  .incident-card p {
    font-size: 0.92rem;
    color: var(--prose);
    line-height: 1.75;
  }
  .incident-card p + p {
    margin-top: 10px;
  }

  /* RESPONSIVE */
  @media (max-width: 700px) {
    .timeline li { grid-template-columns: 72px 1fr; }
    .timeline .t-time { padding: 16px 8px; font-size: 0.75rem; }
    .timeline .t-desc { padding: 16px; }
    .mechanism-2col { grid-template-columns: 1fr; }
    .stat-highlight .stat-num { font-size: 2rem; }
    .incident-card .inc-header { flex-direction: column; gap: 4px; }
  }
</style>
<article>
<div class="page">

  <header class="masthead">
    <div class="issue">Series 09 &mdash; Article 02 of 05</div>
    <h1>force push 하나로 팀을 <strong>멸망</strong>시키는 법</h1>
    <p class="deck">Jenkins 150개 레포 롤백, GitLab DB 삭제 유튜브 라이브 복구, 삼성 190GB 유출. Git 사고는 영화보다 극적이다 &mdash; 그리고 당신에게도 일어날 수 있다.</p>
  </header>

  <main>

    <!-- ========== PART I ========== -->
    <section>
      <div class="section-head">
        <span class="num">Part I</span>
        <h2>전설의 <strong>사고</strong>들</h2>
      </div>

      <p class="prose">Git은 안전한 도구다. 거의 모든 작업을 되돌릴 수 있고, 분산 구조 덕분에 단일 장애점이 없다. 하지만 그 안전장치를 무력화하는 명령어가 몇 개 있다. <strong>force push</strong>, <strong>reset --hard</strong>, 그리고 <strong>실수로 커밋된 비밀 키</strong>. 이 세 가지가 만들어낸 실제 사고들은, 개발자라면 한 번쯤 등줄기가 서늘해지는 이야기다.</p>

      <div class="incident-card">
        <div class="inc-header">
          <span class="inc-name">Jenkins</span>
          <span class="inc-year">2013</span>
        </div>
        <h3>150개 레포지토리가 한 달 전으로 돌아간 날</h3>
        <p>2013년 11월, Jenkins 프로젝트의 GitHub 계정에서 <strong>150개 이상의 레포지토리</strong>가 동시에 약 한 달 전 상태로 롤백되었다. 원인은 Subversion에서 Git으로 마이그레이션하는 과정에서 실행된 스크립트의 force push였다. 자동화 도구가 역사를 다시 쓴 것이다.</p>
        <p>프로젝트 리더 Kohsuke Kawaguchi는 사고 직후 메일링 리스트에 상황을 공지했다. 복구에는 수일이 걸렸고, 일부 레포지토리의 커밋 히스토리는 완전히 복원되지 못했다.</p>
      </div>

      <div style="font-family:var(--serif);font-size:0.8rem;letter-spacing:2px;color:var(--muted);font-weight:700;margin-bottom:16px">Jenkins 사고 타임라인</div>

      <ul class="timeline">
        <li>
          <span class="t-time">Day 0</span>
          <div class="t-desc">SVN-to-Git 마이그레이션 스크립트 실행. <strong>force push가 150+ 레포에 적용</strong>된다.</div>
        </li>
        <li>
          <span class="t-time">+ 30min</span>
          <div class="t-desc">커뮤니티가 이상 징후를 감지. 최근 커밋들이 사라진 것을 발견한다.</div>
        </li>
        <li>
          <span class="t-time">+ 2h</span>
          <div class="t-desc">Kohsuke Kawaguchi가 메일링 리스트에 긴급 공지. <strong>"Do not push anything"</strong> 경고.</div>
        </li>
        <li>
          <span class="t-time">+ 1d</span>
          <div class="t-desc">로컬 클론을 보유한 기여자들의 히스토리를 수집하여 복구 시작.</div>
        </li>
        <li>
          <span class="t-time">+ 5d</span>
          <div class="t-desc">대부분의 레포지토리 복구 완료. 일부 히스토리는 영구 소실.</div>
        </li>
      </ul>

      <div class="incident-card">
        <div class="inc-header">
          <span class="inc-name">GitLab.com</span>
          <span class="inc-year">2017</span>
        </div>
        <h3>300GB 데이터베이스, 4.7GB로 줄어들다</h3>
        <p>2017년 1월 31일, GitLab.com 운영 엔지니어가 데이터베이스 복제 지연 문제를 해결하던 중 <strong>프로덕션 데이터베이스를 삭제</strong>했다. 의도한 것은 스테이징 서버의 디렉토리였으나, 터미널 창을 잘못 선택했다. 6시간 전 백업 한 가지만 살아남았고, 300GB 데이터 중 292GB가 사라졌다.</p>
        <p>GitLab은 전례 없는 결정을 내렸다. <strong>복구 과정 전체를 유튜브 라이브로 중계</strong>한 것이다. 수천 명이 지켜보는 가운데 엔지니어들이 데이터를 복원하는 18시간짜리 마라톤이 벌어졌다. 사후 보고서에서 밝혀진 가장 충격적인 사실은 이것이었다.</p>
      </div>

      <div class="pull-quote">
        <p>"5가지 백업 방법 중 제대로 작동하는 것은 <strong>단 하나도 없었다</strong>"</p>
        <div class="attr">GitLab Post-Mortem, 2017</div>
      </div>

      <p class="prose">pg_dump가 만드는 SQL 백업은 오류와 함께 실패하고 있었고, 아무도 그 사실을 모니터링하지 않았다. Azure 디스크 스냅샷은 비활성화되어 있었다. LVM 스냅샷과 S3 백업도 마찬가지였다. 유일하게 살아남은 것은 사고 6시간 전에 생성된 임시 스냅샷 하나였다.</p>

      <div class="incident-card">
        <div class="inc-header">
          <span class="inc-name">AI Code Tool</span>
          <span class="inc-year">2025&ndash;2026</span>
        </div>
        <h3>AI가 실행한 git reset --hard</h3>
        <p>2025년부터 AI 코딩 에이전트가 터미널 명령을 직접 실행하는 시대가 열렸다. 그리고 예상된 사고가 현실이 되었다. AI 도구가 충돌을 해결하겠다며 <strong>git reset --hard</strong>를 실행하거나, 작업 디렉토리를 정리한다며 커밋되지 않은 변경사항을 날려버리는 사례가 보고되기 시작했다. 인간 개발자도 치지 않을 명령을, AI는 주저 없이 실행한다.</p>
        <p>문제의 핵심은 AI 에이전트가 <strong>명령의 파괴력을 이해하지 못한다</strong>는 것이다. "깨끗한 상태로 만들어줘"라는 프롬프트에 가장 효율적인 응답이 reset --hard일 수 있지만, 그것이 의미하는 데이터 손실은 AI의 고려 대상이 아니다.</p>
      </div>

      <p class="prose">이 세 가지 사고에는 공통점이 있다. 모두 <strong>단 한 줄의 명령어</strong>에서 시작되었다. 그리고 모두 되돌리기 어려웠다. 다음 섹션에서는 그 "되돌리기"의 구체적인 방법을 다룬다.</p>
    </section>

    <!-- ========== PART II ========== -->
    <section>
      <div class="section-head">
        <span class="num">Part II</span>
        <h2>git reset --hard를 치고 <strong>3초 후</strong></h2>
      </div>

      <p class="prose"><strong>git reset</strong>은 세 가지 모드가 있다. 이 차이를 이해하지 못하면, 복구할 수 있었던 상황을 복구 불가능으로 만든다. 핵심은 Git의 세 가지 영역 &mdash; 커밋 히스토리, 스테이징 영역(Index), 작업 디렉토리(Working Directory) &mdash; 중 어디까지 되돌리느냐다.</p>

      <div class="mechanism-row">
        <div class="mechanism">
          <div class="m-label">--soft</div>
          <h3>커밋만 되돌린다</h3>
          <p>HEAD를 이전 커밋으로 이동시키지만, 스테이징 영역과 작업 디렉토리는 그대로 유지한다. 커밋 메시지를 수정하거나, 여러 커밋을 하나로 합칠 때 사용한다. <strong>가장 안전한 옵션.</strong></p>
        </div>
        <div class="mechanism">
          <div class="m-label">--mixed</div>
          <h3>커밋 + 스테이징을 되돌린다</h3>
          <p>기본값. HEAD와 Index를 이전 커밋으로 되돌리지만, 작업 디렉토리의 파일은 유지한다. 변경사항이 unstaged 상태로 남는다. <strong>파일은 살아 있다.</strong></p>
        </div>
        <div class="mechanism">
          <div class="m-label">--hard</div>
          <h3>전부 되돌린다</h3>
          <p>HEAD, Index, 작업 디렉토리 모두를 지정한 커밋으로 되돌린다. 커밋되지 않은 모든 변경사항이 사라진다. <strong>복구 불가능 영역이 존재한다.</strong></p>
        </div>
      </div>

      <div class="warning-box">
        <div class="w-title">커밋하지 않은 작업은 reflog로도 복구 불가</div>
        <ul class="warning-list">
          <li>git add를 하지 않은 새 파일은 Git이 추적하지 않으므로 완전히 사라진다</li>
          <li>스테이징했지만 커밋하지 않은 변경사항은 dangling blob으로 남을 수 있으나 보장되지 않는다</li>
          <li>reset --hard 전에 반드시 git stash 또는 임시 커밋을 만들어라</li>
          <li>IDE의 Local History 기능이 마지막 희망이 될 수 있다 (VS Code, IntelliJ)</li>
        </ul>
      </div>

      <p class="prose"><strong>reflog</strong>는 Git의 타임머신이다. HEAD가 가리켰던 모든 커밋의 로그를 90일간 보관한다. reset --hard로 커밋을 날렸더라도, 그 커밋이 한때 HEAD였다면 reflog에 기록이 남아 있다.</p>

      <div class="code-block"><span class="code-label">reflog로 복구하기</span>
<span class="code-comment"># 1. reflog에서 되돌리고 싶은 커밋 찾기</span>
<span class="code-key">$ git reflog</span>
a1b2c3d HEAD@{0}: reset: moving to HEAD~3
f4e5d6c HEAD@{1}: commit: feat: 결제 모듈 완성
9g8h7i6 HEAD@{2}: commit: fix: 장바구니 버그 수정
j0k1l2m HEAD@{3}: commit: refactor: API 구조 개선

<span class="code-comment"># 2. 원하는 시점으로 복구</span>
<span class="code-key">$ git reset --hard HEAD@{1}</span>
HEAD is now at f4e5d6c feat: 결제 모듈 완성

<span class="code-comment"># 또는 커밋 해시를 직접 지정</span>
<span class="code-key">$ git reset --hard f4e5d6c</span></div>

      <p class="prose">reflog에 커밋이 보이지 않는 극단적인 상황에서는, <strong>git fsck</strong>가 마지막 희망이다. Git 객체 데이터베이스에서 어떤 브랜치에도 연결되지 않은 "고아 객체(dangling object)"를 찾아낸다.</p>

      <div class="code-block"><span class="code-label">fsck로 고아 객체 찾기</span>
<span class="code-comment"># dangling commit 찾기</span>
<span class="code-key">$ git fsck --lost-found</span>
dangling commit a1b2c3d4e5f6...
dangling commit f7g8h9i0j1k2...
dangling blob l3m4n5o6p7q8...

<span class="code-comment"># 내용 확인</span>
<span class="code-key">$ git show a1b2c3d4e5f6</span>

<span class="code-comment"># 원하는 커밋이면 브랜치로 복구</span>
<span class="code-key">$ git branch recovered a1b2c3d4e5f6</span></div>

      <p class="prose">fsck가 찾아내는 dangling object는 Git의 가비지 컬렉션(git gc)이 실행되기 전까지 남아 있다. 기본 설정에서 약 2주의 유예 기간이 있지만, gc.auto 설정에 따라 더 일찍 삭제될 수 있다. 시간이 곧 복구 가능성이다.</p>
    </section>

    <!-- ========== PART III ========== -->
    <section>
      <div class="section-head">
        <span class="num">Part III</span>
        <h2>잘못된 브랜치에 <strong>커밋</strong>했다</h2>
      </div>

      <p class="prose">Stack Overflow의 2023년 설문에 따르면, 개발자의 약 <strong>60%</strong>가 잘못된 브랜치에 커밋한 경험이 있다고 답했다. 가장 흔한 실수는 feature 브랜치 대신 main에 직접 커밋하는 것이다. 아직 push하지 않았다면 비교적 간단하게 해결할 수 있다.</p>

      <div class="code-block"><span class="code-label">cherry-pick으로 커밋 옮기기</span>
<span class="code-comment"># 1. 잘못 커밋한 해시 확인</span>
<span class="code-key">$ git log --oneline -3</span>
a1b2c3d (HEAD -> main) feat: 새 기능 추가    <span class="code-comment"># 이 커밋을 feature로 옮기고 싶다</span>
f4e5d6c fix: 버그 수정
9g8h7i6 docs: README 업데이트

<span class="code-comment"># 2. 올바른 브랜치로 이동 후 cherry-pick</span>
<span class="code-key">$ git checkout feature-branch</span>
<span class="code-key">$ git cherry-pick a1b2c3d</span>

<span class="code-comment"># 3. main에서 잘못된 커밋 제거 (아직 push 전이라면)</span>
<span class="code-key">$ git checkout main</span>
<span class="code-key">$ git reset --hard HEAD~1</span></div>

      <p class="prose">문제는 이미 push한 후다. 원격 저장소에 올라간 커밋을 reset으로 되돌리면, 다른 팀원의 히스토리와 충돌이 발생한다. 이때는 <strong>revert</strong>를 사용해야 한다.</p>

      <div class="mechanism-row mechanism-2col">
        <div class="mechanism">
          <div class="m-label">reset</div>
          <h3>히스토리를 다시 쓴다</h3>
          <p>커밋 자체를 히스토리에서 제거한다. 로컬에서만 사용하거나, force push가 필요하다. 다른 사람이 이미 pull했다면 <strong>모든 팀원의 로컬을 오염시킨다.</strong> push 전에만 안전하게 사용할 수 있다.</p>
        </div>
        <div class="mechanism">
          <div class="m-label">revert</div>
          <h3>되돌리는 커밋을 추가한다</h3>
          <p>기존 커밋을 취소하는 새 커밋을 생성한다. 히스토리가 보존되므로 force push가 필요 없다. <strong>push 후에도 안전하게 사용할 수 있다.</strong> 머지 커밋을 되돌릴 때는 -m 1 옵션이 필요하다.</p>
        </div>
      </div>

      <div class="code-block"><span class="code-label">push 후 머지 되돌리기</span>
<span class="code-comment"># 잘못된 머지 커밋 되돌리기</span>
<span class="code-comment"># -m 1: 첫 번째 부모(main)를 기준으로 되돌린다</span>
<span class="code-key">$ git revert -m 1 &lt;merge-commit-hash&gt;</span>

<span class="code-comment"># 일반 커밋 되돌리기</span>
<span class="code-key">$ git revert &lt;commit-hash&gt;</span>

<span class="code-comment"># 여러 커밋을 한 번에 되돌리기</span>
<span class="code-key">$ git revert --no-commit HEAD~3..HEAD</span>
<span class="code-key">$ git commit -m "revert: 최근 3개 커밋 되돌리기"</span></div>

      <p class="prose">규칙은 단순하다. <strong>push 전에는 reset, push 후에는 revert.</strong> 이 한 줄을 기억하면 잘못된 브랜치 커밋의 90%를 해결할 수 있다.</p>
    </section>

    <!-- ========== PART IV ========== -->
    <section>
      <div class="section-head">
        <span class="num">Part IV</span>
        <h2>2,380만 개의 비밀이 <strong>새어나가는</strong> 곳</h2>
      </div>

      <p class="prose">코드를 잃는 것보다 더 위험한 사고가 있다. <strong>비밀 키를 커밋하는 것</strong>이다. AWS 키, 데이터베이스 비밀번호, API 토큰이 한 번이라도 Git 히스토리에 기록되면, 커밋을 삭제해도 히스토리에 남는다. 그리고 누군가는 반드시 그것을 찾는다.</p>

      <div class="stat-highlight">
        <div class="stat-num">23,800,000</div>
        <div class="stat-label">2024년 한 해 동안 GitHub에서 유출된 시크릿 수<br>GitGuardian State of Secrets Sprawl 2025 Report</div>
      </div>

      <p class="prose">연간 2,380만 건. 하루 평균 65,000건 이상의 비밀이 공개 저장소에 노출되고 있다. 그리고 이것은 GitHub 한 곳의 수치일 뿐이다. GitLab, Bitbucket, 그리고 사내 저장소까지 합치면 실제 규모는 이보다 훨씬 크다.</p>

      <div class="incident-card">
        <div class="inc-header">
          <span class="inc-name">Samsung</span>
          <span class="inc-year">2022</span>
        </div>
        <h3>190GB 소스코드, 6,600개 비밀 키</h3>
        <p>2022년 3월, 해킹 그룹 Lapsus$가 삼성전자에서 <strong>190GB에 달하는 내부 소스코드</strong>를 유출했다. 유출된 코드에는 갤럭시 기기의 신뢰 실행 환경(TrustZone), 생체 인증 잠금 해제 알고리즘, 퀄컴 관련 기밀 소스코드가 포함되어 있었다.</p>
        <p>보안 연구원들이 유출된 코드를 분석한 결과, <strong>6,695개의 하드코딩된 시크릿 키</strong>가 발견되었다. API 키, 인증서, 내부 서비스 토큰이 소스코드에 평문으로 박혀 있었다. Git 히스토리를 관리하지 않은 대가는 상상 이상이었다.</p>
      </div>

      <div class="incident-card">
        <div class="inc-header">
          <span class="inc-name">Uber</span>
          <span class="inc-year">2016</span>
        </div>
        <h3>GitHub 한 줄이 만든 1,900억 원 합의</h3>
        <p>2016년, 공격자가 Uber 개발자의 비공개 GitHub 레포지토리에서 AWS 자격 증명을 발견했다. 이 한 줄의 키로 <strong>5,700만 명의 사용자 데이터</strong>와 60만 명의 운전자 면허 정보에 접근했다. Uber는 이 사실을 1년간 은폐하다 적발되어, 2018년 <strong>1억 4,800만 달러(약 1,900억 원)</strong>의 합의금을 지불했다.</p>
      </div>

      <div class="incident-card">
        <div class="inc-header">
          <span class="inc-name">Mercedes-Benz</span>
          <span class="inc-year">2024</span>
        </div>
        <h3>공개 레포의 토큰 하나, 전체 소스코드 접근</h3>
        <p>2024년 1월, 보안 연구팀 RedHunt Labs가 메르세데스-벤츠의 공개 GitHub 레포지토리에서 <strong>내부 GitHub Enterprise Server의 인증 토큰</strong>을 발견했다. 이 토큰으로 API 키, 클라우드 설정, 설계 문서 등 전체 소스코드에 무제한 접근이 가능했다. <strong>3개월간 아무도 눈치채지 못했다.</strong></p>
      </div>

      <p class="prose">비밀 키가 한 번이라도 Git 히스토리에 들어갔다면, 단순히 파일을 삭제하고 새 커밋을 만드는 것으로는 부족하다. 히스토리에 남은 이전 커밋에서 여전히 조회할 수 있기 때문이다. 히스토리 자체를 다시 써야 한다.</p>

      <div class="code-block"><span class="code-label">git filter-repo로 히스토리에서 비밀 제거</span>
<span class="code-comment"># git filter-repo 설치 (pip)</span>
<span class="code-key">$ pip install git-filter-repo</span>

<span class="code-comment"># 특정 파일을 히스토리 전체에서 제거</span>
<span class="code-key">$ git filter-repo --path config/secrets.yml --invert-paths</span>

<span class="code-comment"># 특정 문자열을 히스토리 전체에서 치환</span>
<span class="code-key">$ git filter-repo --replace-text expressions.txt</span>
<span class="code-comment"># expressions.txt 내용: literal:AKIAIOSFODNN7EXAMPLE==>***REMOVED***</span></div>

      <div class="code-block"><span class="code-label">BFG Repo-Cleaner (대용량 레포에 더 빠름)</span>
<span class="code-comment"># 특정 파일 히스토리에서 제거</span>
<span class="code-key">$ java -jar bfg.jar --delete-files secrets.yml</span>

<span class="code-comment"># 특정 문자열 치환</span>
<span class="code-key">$ java -jar bfg.jar --replace-text passwords.txt</span>

<span class="code-comment"># 정리 후 강제 푸시</span>
<span class="code-key">$ git reflog expire --expire=now --all</span>
<span class="code-key">$ git gc --prune=now --aggressive</span>
<span class="code-key">$ git push --force</span></div>

      <p class="prose">하지만 이미 원격에 push된 비밀은 <strong>히스토리를 다시 써도 안전하지 않다.</strong> 누군가가 이미 fork하거나 clone했을 수 있기 때문이다. 유출된 키는 반드시 즉시 폐기(revoke)하고 새 키를 발급해야 한다. 히스토리 재작성은 최선이 아니라, 추가 피해를 줄이는 차선이다.</p>

      <div style="font-family:var(--serif);font-size:0.8rem;letter-spacing:2px;color:var(--muted);font-weight:700;margin-bottom:16px">유출 방지 도구</div>

      <div class="mechanism-row">
        <div class="mechanism">
          <div class="m-label">gitleaks</div>
          <h3>오픈소스 시크릿 스캐너</h3>
          <p>커밋 전에 pre-commit hook으로 시크릿을 탐지한다. CI/CD 파이프라인에 통합 가능하며, 기존 히스토리 전체를 스캔할 수 있다. GitHub에서 58,000+ 스타를 보유한 업계 표준 도구.</p>
        </div>
        <div class="mechanism">
          <div class="m-label">TruffleHog</div>
          <h3>딥 스캐닝 엔진</h3>
          <p>600개 이상의 시크릿 패턴을 탐지하며, 발견된 키가 실제로 유효한지 자동 검증한다. Git 히스토리뿐 아니라 S3, Slack, Confluence까지 스캔 범위를 확장할 수 있다.</p>
        </div>
        <div class="mechanism">
          <div class="m-label">GitHub Push Protection</div>
          <h3>플랫폼 레벨 차단</h3>
          <p>2023년부터 모든 공개 레포에 기본 활성화. push 시점에 시크릿 패턴을 감지하면 push 자체를 차단한다. 200개 이상의 서비스 패턴을 지원하며, bypass 시 감사 로그가 남는다.</p>
        </div>
      </div>
    </section>

    <!-- ========== PART V ========== -->
    <section>
      <div class="section-head">
        <span class="num">Part V</span>
        <h2>--force-with-lease, 또는 <strong>팀을 지키는</strong> 방법</h2>
      </div>

      <p class="prose">force push가 위험한 이유는 명확하다. 원격 브랜치의 히스토리를 로컬 히스토리로 <strong>무조건 덮어쓰기</strong> 때문이다. 다른 팀원이 그 사이에 push한 커밋이 있어도, 경고 없이 삭제된다. <strong>--force-with-lease</strong>는 이 문제를 해결하는 안전장치다.</p>

      <div class="code-block"><span class="code-label">--force vs --force-with-lease</span>
<span class="code-comment"># 위험: 원격 브랜치를 무조건 덮어쓴다</span>
<span class="code-key">$ git push --force origin feature</span>
<span class="code-comment"># -> 다른 사람의 커밋이 있어도 삭제됨</span>

<span class="code-comment"># 안전: 원격 브랜치가 예상한 상태일 때만 push</span>
<span class="code-key">$ git push --force-with-lease origin feature</span>
<span class="code-comment"># -> 다른 사람이 push한 커밋이 있으면 거부됨</span>

<span class="code-comment"># 더 안전: 구체적인 예상 상태를 명시</span>
<span class="code-key">$ git push --force-with-lease=feature:&lt;expected-hash&gt; origin feature</span></div>

      <p class="prose"><strong>--force-with-lease</strong>는 push 전에 원격 브랜치의 상태를 확인한다. 마지막으로 fetch한 시점의 원격 ref와 현재 원격 ref가 다르면 &mdash; 즉, 누군가 그 사이에 push했다면 &mdash; push를 거부한다. "lease(임대)"라는 이름은 이 메커니즘에서 온 것이다. 당신이 알고 있는 상태를 "임대"하고, 임대 기간이 유효할 때만 갱신을 허용한다.</p>

      <p class="prose">하지만 --force-with-lease에도 맹점이 있다. git fetch를 실행한 직후라면, 원격 ref가 최신 상태로 업데이트되어 다른 사람의 커밋을 알고 있는 것으로 간주된다. 이 경우에도 force push가 성공한다. 근본적인 해결책은 <strong>Protected Branch</strong>다.</p>

      <div class="code-block"><span class="code-label">Protected Branch 설정 (GitHub CLI)</span>
<span class="code-comment"># main 브랜치에 force push 차단 + PR 필수 설정</span>
<span class="code-key">$ gh api repos/{owner}/{repo}/branches/main/protection \</span>
<span class="code-key">  --method PUT \</span>
<span class="code-key">  -f required_pull_request_reviews='{"required_approving_review_count":1}' \</span>
<span class="code-key">  -F allow_force_pushes=false \</span>
<span class="code-key">  -F allow_deletions=false</span></div>

      <div class="warning-box">
        <div class="w-title">Git 사고 예방 체크리스트</div>
        <ul class="warning-list">
          <li><strong>git push --force 대신 --force-with-lease를 사용한다.</strong> 셸 alias로 등록하면 습관이 된다: alias gpf='git push --force-with-lease'</li>
          <li><strong>main/master 브랜치에 Protected Branch를 설정한다.</strong> force push 차단, PR 필수, 최소 1명 리뷰 승인 필수</li>
          <li><strong>pre-commit hook에 gitleaks를 등록한다.</strong> 시크릿이 커밋되기 전에 차단하는 것이 유출 후 정리하는 것보다 100배 쉽다</li>
          <li><strong>git reset --hard 전에 반드시 임시 브랜치를 만든다.</strong> git branch backup-$(date +%s) 한 줄이면 보험이 된다</li>
          <li><strong>.env, credentials, private key 파일은 .gitignore에 등록한다.</strong> 첫 커밋 전에 .gitignore를 설정하는 것이 가장 확실한 방어선이다</li>
          <li><strong>AI 코딩 도구에 파괴적 Git 명령을 허용하지 않는다.</strong> reset --hard, clean -f, push --force는 인간의 확인을 거쳐야 한다</li>
          <li><strong>백업은 테스트하지 않으면 백업이 아니다.</strong> GitLab 사고의 교훈 &mdash; 정기적으로 복구 훈련을 실행한다</li>
        </ul>
      </div>

      <p class="prose">완벽한 예방은 불가능하다. 인간은 실수하고, 자동화 도구는 예상치 못한 동작을 하며, 공격자는 항상 빈틈을 노린다. 하지만 실수의 피해 범위를 줄이는 것은 가능하다. --force-with-lease, Protected Branch, pre-commit hook. 이 세 가지만으로도 대부분의 참사를 예방할 수 있다.</p>
    </section>

  </main>

  <!-- CLOSING -->
  <div class="closing">
    <h2>모든 실수에는<br><strong>되돌아갈 길이 있다</strong></h2>
    <p class="sub">Git은 거의 모든 것을 기억한다. 문제는 당신이 그 기억에 접근하는 방법을 아느냐다. reflog, fsck, filter-repo. 도구는 이미 있다 &mdash; 알고 있기만 하면 된다.</p>
  </div>

  <div class="footer">
    <p>Sources</p>
    <p style="font-size:0.5rem;letter-spacing:2px;line-height:2.2;margin-top:8px">
      Jenkins Infra &mdash; github.com/jenkins-infra (2013) &bull;
      GitLab Post-Mortem &mdash; about.gitlab.com/blog/2017/02/10/postmortem-of-database-outage/ &bull;
      GitGuardian State of Secrets Sprawl 2025 &mdash; gitguardian.com/state-of-secrets-sprawl-report-2025 &bull;
      Samsung / Lapsus$ Breach Analysis &mdash; BleepingComputer (2022) &bull;
      Uber Data Breach Settlement &mdash; FTC.gov (2018) &bull;
      Mercedes-Benz Token Exposure &mdash; RedHunt Labs (2024) &bull;
      GitHub Push Protection &mdash; github.blog/2023-05-09-push-protection-is-generally-available/ &bull;
      git-filter-repo &mdash; github.com/newren/git-filter-repo &bull;
      BFG Repo-Cleaner &mdash; rtyley.github.io/bfg-repo-cleaner/ &bull;
      Stack Overflow Developer Survey 2023 &mdash; survey.stackoverflow.co/2023
    </p>
  </div>

</div>
</article>
