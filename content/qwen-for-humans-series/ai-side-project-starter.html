---
layout: layouts/article.njk
pageTitle: "사이드 프로젝트에 AI 붙이기"
description: "Qwen-Agent, MCP, RAG를 조합해서 나만의 AI 에이전트를 만드는 실행 매뉴얼. 비용 0원, 4주 로드맵으로 문서 요약 봇부터 사내 지식 검색까지."
ogTitle: "사이드 프로젝트에 AI 붙이기 — Qwen-Agent와 RAG로 나만의 AI를 만드는 법"
ogDescription: "비용 0원으로 시작하는 AI 사이드 프로젝트. Ollama + Qwen-Agent + RAG 4주 로드맵."
datePublished: "2026-02-20"
---

{% raw %}
<style>
/* 용어 번역 박스 */
.term-box {
  border-left: 4px solid var(--accent);
  background: var(--card-bg);
  padding: 20px 24px;
  margin: 28px 0 36px;
}
.term-box .term-label {
  font-family: var(--mono);
  font-size: 0.6rem;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: var(--accent);
  font-weight: 600;
  margin-bottom: 8px;
}
.term-box .term-title {
  font-size: 1.15rem;
  font-weight: 700;
  color: var(--fg);
  margin-bottom: 6px;
}
.term-box .term-desc {
  font-size: 0.92rem;
  color: var(--prose);
  line-height: 1.8;
}
.term-box .term-desc strong {
  font-weight: 700;
  color: var(--fg);
}

/* 비교 테이블 */
.compare-table {
  width: 100%;
  border-collapse: collapse;
  margin: 32px 0 40px;
  font-size: 0.88rem;
  line-height: 1.7;
}
.compare-table thead th {
  font-family: var(--mono);
  font-size: 0.6rem;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: var(--muted);
  font-weight: 600;
  text-align: left;
  padding: 12px 16px;
  border-bottom: 2px solid var(--fg);
}
.compare-table tbody td {
  padding: 14px 16px;
  border-bottom: 1px solid var(--rule);
  color: var(--prose);
  vertical-align: top;
}
.compare-table tbody td:first-child {
  font-weight: 700;
  color: var(--fg);
  white-space: nowrap;
}
.compare-table tbody td strong {
  font-weight: 700;
  color: var(--accent);
}
.compare-table tbody tr:last-child td {
  border-bottom: 2px solid var(--fg);
}

/* 코드 블록 */
.code-block {
  background: var(--fg);
  color: var(--bg);
  padding: 24px 28px;
  margin: 28px 0 36px;
  font-family: var(--mono);
  font-size: 0.78rem;
  line-height: 1.9;
  overflow-x: auto;
  tab-size: 2;
}
[data-theme="dark"] .code-block {
  background: var(--card-bg);
  color: var(--fg);
  border: 1px solid var(--rule);
}
.code-block .c-comment {
  opacity: 0.4;
}
.code-block .c-keyword {
  color: #e0604e;
}
[data-theme="dark"] .code-block .c-keyword {
  color: var(--accent);
}
.code-block .c-string {
  color: #8bc28b;
}
[data-theme="dark"] .code-block .c-string {
  color: #8bc28b;
}
.code-block .c-label {
  font-size: 0.6rem;
  letter-spacing: 3px;
  text-transform: uppercase;
  opacity: 0.5;
  display: block;
  margin-bottom: 12px;
}

/* 프로젝트 아이디어 그리드 */
.idea-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1px;
  background: var(--rule);
  border: 1px solid var(--rule);
  margin: 36px 0 44px;
}
.idea-card {
  background: var(--bg);
  padding: 28px 24px;
}
.idea-card .i-label {
  font-family: var(--mono);
  font-size: 0.6rem;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: var(--muted);
  font-weight: 500;
  margin-bottom: 10px;
}
.idea-card .i-title {
  font-size: 1.05rem;
  font-weight: 700;
  color: var(--fg);
  margin-bottom: 6px;
}
.idea-card .i-desc {
  font-size: 0.85rem;
  color: var(--secondary);
  line-height: 1.7;
  margin-bottom: 8px;
}
.idea-card .i-stack {
  font-family: var(--mono);
  font-size: 0.65rem;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--accent);
  font-weight: 600;
}

/* 로드맵 */
.roadmap {
  margin: 40px 0 48px;
  display: grid;
  gap: 1px;
  background: var(--rule);
  border: 1px solid var(--rule);
}
.rm-week {
  background: var(--bg);
  display: grid;
  grid-template-columns: 80px 1fr;
  gap: 0;
}
.rm-week .rm-num {
  background: var(--card-bg);
  padding: 24px 16px;
  text-align: center;
}
.rm-week .rm-num .rm-n {
  font-family: var(--mono);
  font-size: 1.3rem;
  font-weight: 800;
  color: var(--accent);
  display: block;
}
.rm-week .rm-num .rm-sub {
  font-family: var(--mono);
  font-size: 0.55rem;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: var(--muted);
  font-weight: 600;
}
.rm-week .rm-body {
  padding: 24px 28px;
}
.rm-week .rm-title {
  font-size: 1rem;
  font-weight: 700;
  color: var(--fg);
  margin-bottom: 6px;
}
.rm-week .rm-desc {
  font-size: 0.88rem;
  color: var(--secondary);
  line-height: 1.75;
}
.rm-week .rm-desc strong {
  font-weight: 700;
  color: var(--fg);
}
.rm-week .rm-output {
  font-family: var(--mono);
  font-size: 0.65rem;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--accent);
  font-weight: 600;
  margin-top: 10px;
  display: block;
}

/* 아키텍처 다이어그램 */
.arch {
  margin: 36px 0 44px;
  border: 1px solid var(--rule);
  padding: 32px 28px;
  text-align: center;
}
.arch-label {
  font-family: var(--mono);
  font-size: 0.6rem;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: var(--muted);
  font-weight: 600;
  margin-bottom: 20px;
}
.arch-row {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  margin: 12px 0;
  flex-wrap: wrap;
}
.arch-box {
  border: 1px solid var(--fg);
  padding: 10px 18px;
  font-size: 0.82rem;
  font-weight: 700;
  color: var(--fg);
}
.arch-box.accent {
  background: var(--accent);
  color: var(--bg);
  border-color: var(--accent);
}
.arch-arrow {
  font-size: 0.85rem;
  color: var(--muted);
}

/* 반응형 */
@media (max-width: 700px) {
  .idea-grid { grid-template-columns: 1fr; }
  .code-block { padding: 16px 18px; font-size: 0.72rem; }
  .rm-week { grid-template-columns: 60px 1fr; }
  .rm-week .rm-num { padding: 18px 10px; }
  .rm-week .rm-num .rm-n { font-size: 1rem; }
  .rm-week .rm-body { padding: 18px 20px; }
  .compare-table { font-size: 0.8rem; }
  .compare-table thead th,
  .compare-table tbody td { padding: 10px 10px; }
  .arch-row { gap: 8px; }
  .arch-box { padding: 8px 12px; font-size: 0.75rem; }
}
</style>

<article>
<div class="page">

<header class="masthead">
  <span class="issue">Series 36 &middot; 04 of 05</span>
  <h1>사이드 프로젝트에<br><strong>AI 붙이기</strong></h1>
  <p class="deck">Qwen-Agent, MCP, RAG. 이름이 어려워 보이지만 조립은 쉽다. 비용 0원, 4주면 나만의 AI를 만들 수 있다.</p>
</header>

<main>

<!-- ===== PART I ===== -->
<section>
  <div class="section-head">
    <span class="num">Part I — Why</span>
    <h2>사이드 프로젝트에 <strong>AI가 필요한 순간</strong></h2>
  </div>

  <p class="prose">AI를 사이드 프로젝트에 붙인다는 것은, ChatGPT 같은 대화 인터페이스를 만든다는 뜻이 아니다. <strong>내 데이터에 맞춰진, 내 작업을 자동화하는 AI</strong>를 만든다는 뜻이다.</p>

  <p class="prose">일상에서 반복되는 작업을 생각해보자. 매번 같은 질문에 답해야 하는 고객 응대. 길고 지루한 회의록 정리. 매주 쌓이는 기술 문서 읽기. 이런 작업에 AI를 붙이면, 사람은 판단만 하고 나머지는 AI가 처리한다.</p>

  <div class="idea-grid">
    <div class="idea-card">
      <div class="i-label">Idea 01</div>
      <div class="i-title">문서 요약 봇</div>
      <div class="i-desc">PDF, 웹 페이지, 이메일을 넣으면 핵심만 3줄로 요약. 256K 컨텍스트로 긴 문서도 통째로 처리 가능.</div>
      <div class="i-stack">Ollama + Python script</div>
    </div>
    <div class="idea-card">
      <div class="i-label">Idea 02</div>
      <div class="i-title">코드 리뷰 자동화</div>
      <div class="i-desc">Git commit이 올라오면 변경된 코드를 읽고 잠재적 버그, 스타일 위반, 성능 이슈를 리포트.</div>
      <div class="i-stack">Qwen-Agent + Git hooks</div>
    </div>
    <div class="idea-card">
      <div class="i-label">Idea 03</div>
      <div class="i-title">개인 지식 검색</div>
      <div class="i-desc">내 노트, 북마크, 메모를 전부 인덱싱. "지난달에 읽은 그 논문에서 뭐라고 했지?"에 답하는 AI.</div>
      <div class="i-stack">RAG + Vector DB</div>
    </div>
    <div class="idea-card">
      <div class="i-label">Idea 04</div>
      <div class="i-title">FAQ 챗봇</div>
      <div class="i-desc">자주 묻는 질문을 학습시켜서 자동 응답. 사내 위키나 제품 매뉴얼을 데이터 소스로 연결.</div>
      <div class="i-stack">RAG + MCP + Web UI</div>
    </div>
  </div>

  <p class="prose">이 프로젝트들의 공통점이 있다. <strong>기존 데이터가 있고, 그 데이터를 기반으로 AI가 답하는 구조</strong>다. 이것을 기술적으로는 RAG(Retrieval-Augmented Generation)라고 부른다. 사이드 프로젝트에 AI를 붙이는 가장 실용적인 방법이다.</p>
</section>

<!-- ===== PART II ===== -->
<section>
  <div class="section-head">
    <span class="num">Part II — Qwen-Agent</span>
    <h2>나만의 <strong>에이전트</strong> 만들기</h2>
  </div>

  <p class="prose">3편에서 에이전트의 개념을 설명했다. AI가 도구를 사용해서 작업을 수행하는 것. 이것을 실제로 만들려면 프레임워크가 필요하다. <strong>Qwen-Agent</strong>가 그 역할을 한다.</p>

  <div class="term-box">
    <div class="term-label">translate</div>
    <div class="term-title">Qwen-Agent</div>
    <div class="term-desc">Qwen 모델 위에서 에이전트를 만들 수 있게 해주는 <strong>오픈소스 프레임워크</strong>. 함수 호출, MCP, 코드 인터프리터, RAG를 지원한다. 레고 블록처럼 필요한 기능을 조합해서 에이전트를 조립하는 도구 상자다.</div>
  </div>

  <p class="prose">가장 간단한 에이전트를 만들어보자. 파일을 읽고 요약하는 에이전트다. 파이썬 코드 10줄이면 된다.</p>

  <div class="code-block">
    <span class="c-label">Python — file-summary-agent.py</span>
    <span class="c-keyword">from</span> qwen_agent.agents <span class="c-keyword">import</span> Assistant<br>
    <br>
    <span class="c-comment"># 에이전트 생성 — Ollama 로컬 모델 사용</span><br>
    bot = Assistant(<br>
    &nbsp;&nbsp;llm={<br>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="c-string">'model'</span>: <span class="c-string">'qwen3:14b'</span>,<br>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="c-string">'model_server'</span>: <span class="c-string">'http://localhost:11434/v1'</span>,<br>
    &nbsp;&nbsp;},<br>
    &nbsp;&nbsp;function_list=[<span class="c-string">'code_interpreter'</span>],<br>
    )<br>
    <br>
    <span class="c-comment"># 파일을 읽고 요약해달라고 요청</span><br>
    messages = [{<br>
    &nbsp;&nbsp;<span class="c-string">'role'</span>: <span class="c-string">'user'</span>,<br>
    &nbsp;&nbsp;<span class="c-string">'content'</span>: <span class="c-string">'report.pdf를 읽고 핵심 3줄로 요약해줘'</span>,<br>
    }]<br>
    <br>
    <span class="c-keyword">for</span> response <span class="c-keyword">in</span> bot.run(messages):<br>
    &nbsp;&nbsp;print(response)
  </div>

  <p class="prose">이 코드가 하는 일을 단계별로 보자.</p>

  <div class="mechanism-row">
    <div class="mechanism">
      <div class="m-label">Step 01</div>
      <h3>에이전트 생성</h3>
      <p>Ollama에서 실행 중인 Qwen3-14B 모델에 연결한다. 도구로 코드 인터프리터를 사용하도록 설정한다.</p>
    </div>
    <div class="mechanism">
      <div class="m-label">Step 02</div>
      <h3>사용자 요청</h3>
      <p>"report.pdf를 읽고 요약해줘." AI가 이 요청을 분석하여, 파일을 읽는 코드를 직접 작성하고 실행한다.</p>
    </div>
    <div class="mechanism">
      <div class="m-label">Step 03</div>
      <h3>도구 실행</h3>
      <p>코드 인터프리터가 PDF를 열고 텍스트를 추출한다. AI가 그 텍스트를 읽고 3줄 요약을 생성한다.</p>
    </div>
  </div>

  <p class="prose">여기에 <strong>MCP</strong>를 추가하면 더 강력해진다. MCP 설정 파일 하나로 파일 시스템, 데이터베이스, 외부 API를 도구로 연결할 수 있다.</p>

  <div class="code-block">
    <span class="c-label">JSON — mcp-config.json</span>
    {<br>
    &nbsp;&nbsp;<span class="c-string">"mcpServers"</span>: {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="c-string">"filesystem"</span>: {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c-string">"command"</span>: <span class="c-string">"npx"</span>,<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="c-string">"args"</span>: [<span class="c-string">"@anthropic/mcp-filesystem"</span>, <span class="c-string">"/home/user/docs"</span>]<br>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
    &nbsp;&nbsp;}<br>
    }
  </div>

  <p class="prose">이 설정 하나면 에이전트가 <strong>/home/user/docs 폴더 안의 모든 파일을 읽을 수 있다</strong>. 사용자가 "지난주 회의록에서 결정된 사항을 정리해줘"라고 하면, 에이전트가 직접 회의록 파일을 찾아서 읽고 정리한다. 사람이 파일을 복사해서 붙여넣을 필요가 없다.</p>
</section>

<!-- ===== PART III ===== -->
<section>
  <div class="section-head">
    <span class="num">Part III — RAG</span>
    <h2>내 문서로 답하는 <strong>AI</strong></h2>
  </div>

  <p class="prose">사이드 프로젝트에서 가장 실용적인 AI 활용은 <strong>RAG 챗봇</strong>이다. 내 문서, 내 데이터를 기반으로 질문에 답하는 AI. ChatGPT와의 차이는 명확하다. ChatGPT는 인터넷에서 학습한 범용 지식으로 답하지만, RAG 챗봇은 <strong>내가 넣어준 문서에서만 답한다</strong>.</p>

  <div class="term-box">
    <div class="term-label">translate</div>
    <div class="term-title">RAG (Retrieval-Augmented Generation)</div>
    <div class="term-desc">AI에게 <strong>커닝 페이퍼를 주는 것</strong>. 시험을 보기 전에 관련 자료를 먼저 찾아서(Retrieval) AI에게 건네주고, 그 자료를 참고해서 답하게(Generation) 하는 방식. AI가 모르는 것도 자료만 있으면 답할 수 있다.</div>
  </div>

  <p class="prose">RAG의 동작 원리를 단계별로 보자.</p>

  <div class="arch">
    <div class="arch-label">RAG Architecture</div>
    <div class="arch-row">
      <div class="arch-box">내 문서</div>
      <div class="arch-arrow">→</div>
      <div class="arch-box">텍스트 추출</div>
      <div class="arch-arrow">→</div>
      <div class="arch-box">임베딩 변환</div>
      <div class="arch-arrow">→</div>
      <div class="arch-box accent">벡터 DB 저장</div>
    </div>
    <div class="arch-row">
      <div class="arch-arrow">↓ 질문이 들어오면</div>
    </div>
    <div class="arch-row">
      <div class="arch-box">사용자 질문</div>
      <div class="arch-arrow">→</div>
      <div class="arch-box accent">벡터 DB 검색</div>
      <div class="arch-arrow">→</div>
      <div class="arch-box">관련 문서 조각</div>
      <div class="arch-arrow">→</div>
      <div class="arch-box accent">Qwen이 답변 생성</div>
    </div>
  </div>

  <div class="term-box">
    <div class="term-label">translate</div>
    <div class="term-title">벡터 DB (Vector Database)</div>
    <div class="term-desc">문서를 <strong>숫자 배열(벡터)로 변환해서 저장</strong>하는 특수한 데이터베이스. "의미가 비슷한 문장"을 빠르게 찾을 수 있다. "매출 보고서"를 검색하면 "이번 분기 실적"도 함께 찾아준다. 대표적인 도구로 Milvus, ChromaDB, FAISS가 있다.</div>
  </div>

  <p class="prose">Qwen3.5가 RAG에 특히 유리한 이유가 두 가지 있다.</p>

  <p class="prose">첫째, <strong>256K 컨텍스트</strong>. 벡터 DB에서 관련 문서 조각을 찾아왔을 때, 그 조각이 여러 개라도 한 번에 넣을 수 있다. 컨텍스트가 작은 모델은 문서 조각 2~3개밖에 못 넣지만, Qwen3.5는 수십 개를 넣고도 여유가 있다. 답변의 정확도가 올라간다.</p>

  <p class="prose">둘째, <strong>올인원 파이프라인</strong>. 보통 RAG를 만들려면 세 가지 모델이 필요하다. 임베딩 모델(문서→벡터 변환), 리랭킹 모델(검색 결과 정렬), 생성 모델(답변 작성). Qwen 패밀리는 이 세 가지를 <strong>하나의 모델 패밀리</strong>로 해결할 수 있다. 서로 다른 회사의 모델을 조합할 때 생기는 호환성 문제가 없다.</p>

  <table class="compare-table">
    <thead>
      <tr>
        <th>Component</th>
        <th>Tool</th>
        <th>Role</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>AI 모델</td>
        <td><strong>Qwen3 (Ollama)</strong></td>
        <td>질문을 이해하고, 문서를 읽고, 답변을 생성</td>
      </tr>
      <tr>
        <td>벡터 DB</td>
        <td><strong>ChromaDB or Milvus</strong></td>
        <td>문서를 벡터로 저장하고 유사도 검색</td>
      </tr>
      <tr>
        <td>프레임워크</td>
        <td><strong>LangChain or Qwen-Agent</strong></td>
        <td>모델, DB, 도구를 연결하는 접착제</td>
      </tr>
      <tr>
        <td>임베딩</td>
        <td><strong>Qwen3-Embedding</strong></td>
        <td>텍스트를 숫자 벡터로 변환</td>
      </tr>
    </tbody>
  </table>

  <div class="pull-quote">
    <p>RAG의 핵심은 AI를 똑똑하게 만드는 것이 아니다.<br><strong>AI에게 올바른 자료를 주는 것</strong>이다.<br>자료가 좋으면 8B 모델도 놀라운 답변을 한다.</p>
  </div>

  <p class="prose">한 가지 더. Qwen3.5의 256K 컨텍스트(확장 시 1M)가 충분히 크기 때문에, 문서 양이 적다면 <strong>RAG 없이도 문서 전체를 컨텍스트에 넣는 방식</strong>도 가능하다. A4 100페이지 이내의 매뉴얼이라면 벡터 DB 없이 통째로 넣어서 질문할 수 있다. RAG 구축의 복잡함을 건너뛰는 방법이다.</p>
</section>

<!-- ===== PART IV ===== -->
<section>
  <div class="section-head">
    <span class="num">Part IV — Roadmap</span>
    <h2>비용 0원으로 시작하는 <strong>4주 로드맵</strong></h2>
  </div>

  <p class="prose">사이드 프로젝트는 첫 발을 내딛는 것이 가장 어렵다. 나머지는 관성이 해결한다. 4주 로드맵의 원칙은 <strong>"작게 시작하고, 매주 한 단계씩 확장한다"</strong>다.</p>

  <div class="roadmap">
    <div class="rm-week">
      <div class="rm-num">
        <span class="rm-n">01</span>
        <span class="rm-sub">Week</span>
      </div>
      <div class="rm-body">
        <div class="rm-title">Ollama 설치 + 대화</div>
        <div class="rm-desc">Ollama를 설치하고 <strong>Qwen3-8B</strong>를 실행한다. 다양한 질문을 던져보면서 모델의 성격을 파악한다. 한국어 요약, 번역, 코드 생성을 시도해본다. 이 단계의 목표는 "로컬 AI가 어떤 느낌인지 체험하는 것"이다.</div>
        <span class="rm-output">Output: 로컬 AI 실행 환경</span>
      </div>
    </div>
    <div class="rm-week">
      <div class="rm-num">
        <span class="rm-n">02</span>
        <span class="rm-sub">Week</span>
      </div>
      <div class="rm-body">
        <div class="rm-title">Python + Ollama API 연동</div>
        <div class="rm-desc">Ollama의 로컬 API를 파이썬에서 호출한다. <strong>requests 라이브러리 하나면 충분</strong>하다. 터미널 대화를 넘어서, 자기만의 스크립트에서 AI를 호출하는 단계. 파일을 읽어서 AI에게 전달하고, 결과를 파일로 저장하는 것까지 시도한다.</div>
        <span class="rm-output">Output: 파일 요약 스크립트</span>
      </div>
    </div>
    <div class="rm-week">
      <div class="rm-num">
        <span class="rm-n">03</span>
        <span class="rm-sub">Week</span>
      </div>
      <div class="rm-body">
        <div class="rm-title">RAG 파이프라인 구축</div>
        <div class="rm-desc"><strong>ChromaDB</strong>를 설치하고 내 문서를 벡터로 변환한다. 질문이 들어오면 관련 문서를 검색하고, Qwen에게 전달하여 답변을 생성하는 파이프라인을 만든다. 문서 10~50개 규모로 시작하면 충분하다.</div>
        <span class="rm-output">Output: 로컬 RAG 챗봇</span>
      </div>
    </div>
    <div class="rm-week">
      <div class="rm-num">
        <span class="rm-n">04</span>
        <span class="rm-sub">Week</span>
      </div>
      <div class="rm-body">
        <div class="rm-title">MCP 도구 확장</div>
        <div class="rm-desc">Qwen-Agent를 도입하고, <strong>MCP로 외부 도구를 연결</strong>한다. 파일 시스템 접근, 웹 검색, 코드 실행 등 에이전트의 능력을 확장한다. "이 폴더에서 최신 보고서를 찾아서 요약해줘" 같은 복합 작업이 가능해진다.</div>
        <span class="rm-output">Output: 도구 사용 에이전트</span>
      </div>
    </div>
  </div>

  <p class="prose">이 4주 로드맵에서 드는 비용은 <strong>0원</strong>이다. Ollama(무료), Qwen3 모델(무료), ChromaDB(무료), Qwen-Agent(무료), 파이썬(무료). 필요한 것은 GPU가 달린 PC와 시간뿐이다.</p>

  <p class="prose">GPU가 없다면 어떻게 하는가. 두 가지 대안이 있다. 첫째, <strong>Google Colab</strong>에서 무료 GPU를 쓸 수 있다 (세션 제한 있음). 둘째, <strong>Qwen3.5-Plus API</strong>를 사용하면 로컬 GPU 없이도 동일한 파이프라인을 구축할 수 있다. API는 유료지만 소규모 사이드 프로젝트 수준이라면 월 수천~수만 원 이내다.</p>

  <div class="warning-box">
    <div class="w-title">사이드 프로젝트를 망치는 흔한 실수</div>
    <ul class="warning-list">
      <li>처음부터 완벽한 시스템을 만들려 한다. 첫 주에는 대화만 해봐도 충분하다</li>
      <li>데이터 정리를 건너뛴다. AI의 답변 품질은 넣어주는 데이터의 품질에 비례한다</li>
      <li>모델 크기에 집착한다. 대부분의 사이드 프로젝트에서 8B면 충분하다</li>
      <li>웹 UI부터 만든다. 터미널에서 동작하는 것을 먼저 확인하고, UI는 나중에 붙인다</li>
      <li>혼자 다 하려 한다. Qwen-Agent, LangChain 같은 프레임워크가 이미 복잡한 부분을 해결해놓았다</li>
    </ul>
  </div>
</section>

</main>

<div class="closing">
  <h2>AI 사이드 프로젝트의 시작은<br>거창한 아이디어가 아니다.<br><strong>ollama run qwen3:8b</strong></h2>
  <p class="sub">첫 주에 대화하고, 둘째 주에 코드를 연결하고, 셋째 주에 문서를 붙이고, 넷째 주에 도구를 확장한다. 나머지는 관성이 한다.</p>
</div>

<footer class="footer">
  <p>Sources: Qwen-Agent GitHub (2026) &middot; Milvus RAG Guide (2026) &middot; FreeCodeCamp Local AI (2026) &middot; Qwen MCP Documentation (2026)</p>
  <p>Research assisted by Claude &middot; 2026</p>
</footer>

</div>
</article>
{% endraw %}
